/* tslint:disable */
/* eslint-disable */
/**
 * lap-legend-race-game
 * Your custom SDK
 *
 * The version of the OpenAPI document: lap-legend-race-game: v1 SDK
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ApiHttpBody,
  AuthAnonLoginRequest,
  AuthAnonLoginResponse,
  AuthAppleLoginRequest,
  AuthAppleLoginResponse,
  AuthAssociateLoginsRequest,
  AuthDiscordLoginRequest,
  AuthDiscordLoginResponse,
  AuthEmailLoginRequest,
  AuthEmailLoginResponse,
  AuthEmailPasswordLoginRequest,
  AuthEmailPasswordLoginResponse,
  AuthEpicLoginRequest,
  AuthEpicLoginResponse,
  AuthFacebookLoginRequest,
  AuthFacebookLoginResponse,
  AuthGetUserIdsByLoginIdsResponse,
  AuthGetUsernameAvailabilityResponse,
  AuthGoogleLoginRequest,
  AuthGoogleLoginResponse,
  AuthOtpRequest,
  AuthRecoverEmailAccountRequest,
  AuthRefreshRequest,
  AuthRefreshResponse,
  AuthSteamLoginRequest,
  AuthSteamLoginResponse,
  AuthSteamOpenIdLoginRequest,
  AuthSteamSessionTicketLoginRequest,
  AuthSuspendUserResponse,
  AuthUpdateEmailPasswordRequest,
  AuthUpdateUsernamePasswordRequest,
  AuthUsernamePasswordLoginRequest,
  AuthUsernamePasswordLoginResponse,
  AuthValidateRequest,
  AuthValidateResponse,
  AuthVerifyEmailRequest,
  AuthVerifyEmailResponse,
  AuthXboxLoginRequest,
  AuthXboxLoginResponse,
  DisassociateLoginRequest,
  SuspendUserRequest,
} from '../models/index';
import {
    ApiHttpBodyFromJSON,
    ApiHttpBodyToJSON,
    AuthAnonLoginRequestFromJSON,
    AuthAnonLoginRequestToJSON,
    AuthAnonLoginResponseFromJSON,
    AuthAnonLoginResponseToJSON,
    AuthAppleLoginRequestFromJSON,
    AuthAppleLoginRequestToJSON,
    AuthAppleLoginResponseFromJSON,
    AuthAppleLoginResponseToJSON,
    AuthAssociateLoginsRequestFromJSON,
    AuthAssociateLoginsRequestToJSON,
    AuthDiscordLoginRequestFromJSON,
    AuthDiscordLoginRequestToJSON,
    AuthDiscordLoginResponseFromJSON,
    AuthDiscordLoginResponseToJSON,
    AuthEmailLoginRequestFromJSON,
    AuthEmailLoginRequestToJSON,
    AuthEmailLoginResponseFromJSON,
    AuthEmailLoginResponseToJSON,
    AuthEmailPasswordLoginRequestFromJSON,
    AuthEmailPasswordLoginRequestToJSON,
    AuthEmailPasswordLoginResponseFromJSON,
    AuthEmailPasswordLoginResponseToJSON,
    AuthEpicLoginRequestFromJSON,
    AuthEpicLoginRequestToJSON,
    AuthEpicLoginResponseFromJSON,
    AuthEpicLoginResponseToJSON,
    AuthFacebookLoginRequestFromJSON,
    AuthFacebookLoginRequestToJSON,
    AuthFacebookLoginResponseFromJSON,
    AuthFacebookLoginResponseToJSON,
    AuthGetUserIdsByLoginIdsResponseFromJSON,
    AuthGetUserIdsByLoginIdsResponseToJSON,
    AuthGetUsernameAvailabilityResponseFromJSON,
    AuthGetUsernameAvailabilityResponseToJSON,
    AuthGoogleLoginRequestFromJSON,
    AuthGoogleLoginRequestToJSON,
    AuthGoogleLoginResponseFromJSON,
    AuthGoogleLoginResponseToJSON,
    AuthOtpRequestFromJSON,
    AuthOtpRequestToJSON,
    AuthRecoverEmailAccountRequestFromJSON,
    AuthRecoverEmailAccountRequestToJSON,
    AuthRefreshRequestFromJSON,
    AuthRefreshRequestToJSON,
    AuthRefreshResponseFromJSON,
    AuthRefreshResponseToJSON,
    AuthSteamLoginRequestFromJSON,
    AuthSteamLoginRequestToJSON,
    AuthSteamLoginResponseFromJSON,
    AuthSteamLoginResponseToJSON,
    AuthSteamOpenIdLoginRequestFromJSON,
    AuthSteamOpenIdLoginRequestToJSON,
    AuthSteamSessionTicketLoginRequestFromJSON,
    AuthSteamSessionTicketLoginRequestToJSON,
    AuthSuspendUserResponseFromJSON,
    AuthSuspendUserResponseToJSON,
    AuthUpdateEmailPasswordRequestFromJSON,
    AuthUpdateEmailPasswordRequestToJSON,
    AuthUpdateUsernamePasswordRequestFromJSON,
    AuthUpdateUsernamePasswordRequestToJSON,
    AuthUsernamePasswordLoginRequestFromJSON,
    AuthUsernamePasswordLoginRequestToJSON,
    AuthUsernamePasswordLoginResponseFromJSON,
    AuthUsernamePasswordLoginResponseToJSON,
    AuthValidateRequestFromJSON,
    AuthValidateRequestToJSON,
    AuthValidateResponseFromJSON,
    AuthValidateResponseToJSON,
    AuthVerifyEmailRequestFromJSON,
    AuthVerifyEmailRequestToJSON,
    AuthVerifyEmailResponseFromJSON,
    AuthVerifyEmailResponseToJSON,
    AuthXboxLoginRequestFromJSON,
    AuthXboxLoginRequestToJSON,
    AuthXboxLoginResponseFromJSON,
    AuthXboxLoginResponseToJSON,
    DisassociateLoginRequestFromJSON,
    DisassociateLoginRequestToJSON,
    SuspendUserRequestFromJSON,
    SuspendUserRequestToJSON,
} from '../models/index';

export interface AnonLoginRequest {
    body: AuthAnonLoginRequest;
}

export interface AppBanRequest {
    id: string;
    token: string;
    body: object;
}

export interface AppUnbanRequest {
    id: string;
    token: string;
    body: object;
}

export interface AppVerifyRequest {
    type: string;
    sessionToken?: string;
    clientSecret?: string;
}

export interface AppleLoginRequest {
    body: AuthAppleLoginRequest;
}

export interface AssociateLoginsRequest {
    body: AuthAssociateLoginsRequest;
}

export interface DisassociateLoginOperationRequest {
    userId: string;
    token: string;
    body: DisassociateLoginRequest;
}

export interface DiscordLoginRequest {
    body: AuthDiscordLoginRequest;
}

export interface EmailLoginRequest {
    body: AuthEmailLoginRequest;
}

export interface EmailPasswordLoginRequest {
    body: AuthEmailPasswordLoginRequest;
}

export interface EpicLoginRequest {
    body: AuthEpicLoginRequest;
}

export interface FacebookLoginRequest {
    body: AuthFacebookLoginRequest;
}

export interface GetUserIdsByLoginIdsRequest {
    loginIds: string;
    loginType: string;
    token: string;
}

export interface GetUsernameAvailabilityRequest {
    username: string;
}

export interface GoogleLoginRequest {
    body: AuthGoogleLoginRequest;
}

export interface LogoutRequest {
    token: string;
    token2: string;
}

export interface OtpRequest {
    body: AuthOtpRequest;
}

export interface RecoverEmailAccountRequest {
    body: AuthRecoverEmailAccountRequest;
}

export interface RefreshRequest {
    token: string;
    body: AuthRefreshRequest;
}

export interface SteamLoginRequest {
    body: AuthSteamLoginRequest;
}

export interface SteamOpenIdLoginRequest {
    body: AuthSteamOpenIdLoginRequest;
}

export interface SteamSessionTicketLoginRequest {
    body: AuthSteamSessionTicketLoginRequest;
}

export interface SuspendUserOperationRequest {
    id: string;
    token: string;
    body: SuspendUserRequest;
}

export interface UpdateEmailPasswordRequest {
    body: AuthUpdateEmailPasswordRequest;
}

export interface UpdateUsernamePasswordRequest {
    token: string;
    body: AuthUpdateUsernamePasswordRequest;
}

export interface UsernamePasswordLoginRequest {
    body: AuthUsernamePasswordLoginRequest;
}

export interface ValidateRequest {
    body: AuthValidateRequest;
}

export interface VerifyEmailRequest {
    body: AuthVerifyEmailRequest;
}

export interface XboxLoginRequest {
    body: AuthXboxLoginRequest;
}

/**
 * 
 */
export class AuthServiceApi extends runtime.BaseAPI {

    /**
     * Logs in the user with an arbitrary identifier specified and returns a session
     * Anonymous Login
     */
    async anonLoginRaw(requestParameters: AnonLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthAnonLoginResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling anonLogin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/auth/login/anon`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AuthAnonLoginRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthAnonLoginResponseFromJSON(jsonValue));
    }

    /**
     * Logs in the user with an arbitrary identifier specified and returns a session
     * Anonymous Login
     */
    async anonLogin(requestParameters: AnonLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthAnonLoginResponse> {
        const response = await this.anonLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Bans the user based on the user ID specified
     * Ban User
     */
    async appBanRaw(requestParameters: AppBanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling appBan.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling appBan.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling appBan.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/auth/user/{id}/ban`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Bans the user based on the user ID specified
     * Ban User
     */
    async appBan(requestParameters: AppBanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.appBanRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Unbans the user based on the user ID specified
     * Unban User
     */
    async appUnbanRaw(requestParameters: AppUnbanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling appUnban.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling appUnban.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling appUnban.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/auth/user/{id}/unban`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Unbans the user based on the user ID specified
     * Unban User
     */
    async appUnban(requestParameters: AppUnbanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.appUnbanRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Verifies the session token and returns appropriate response based on the type
     * Token
     */
    async appVerifyRaw(requestParameters: AppVerifyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiHttpBody>> {
        if (requestParameters.type === null || requestParameters.type === undefined) {
            throw new runtime.RequiredError('type','Required parameter requestParameters.type was null or undefined when calling appVerify.');
        }

        const queryParameters: any = {};

        if (requestParameters.sessionToken !== undefined) {
            queryParameters['session_token'] = requestParameters.sessionToken;
        }

        if (requestParameters.clientSecret !== undefined) {
            queryParameters['client_secret'] = requestParameters.clientSecret;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/auth/app-verify/{type}`.replace(`{${"type"}}`, encodeURIComponent(String(requestParameters.type))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiHttpBodyFromJSON(jsonValue));
    }

    /**
     * Verifies the session token and returns appropriate response based on the type
     * Token
     */
    async appVerify(requestParameters: AppVerifyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiHttpBody> {
        const response = await this.appVerifyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Logs in the user based on the apple credential token specified and returns a session
     * Apple Login
     */
    async appleLoginRaw(requestParameters: AppleLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthAppleLoginResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling appleLogin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/auth/login/apple`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AuthAppleLoginRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthAppleLoginResponseFromJSON(jsonValue));
    }

    /**
     * Logs in the user based on the apple credential token specified and returns a session
     * Apple Login
     */
    async appleLogin(requestParameters: AppleLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthAppleLoginResponse> {
        const response = await this.appleLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Associates two logins based on their session tokens
     * Associate Multiple Logins
     */
    async associateLoginsRaw(requestParameters: AssociateLoginsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling associateLogins.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/auth/associate-logins`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AuthAssociateLoginsRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Associates two logins based on their session tokens
     * Associate Multiple Logins
     */
    async associateLogins(requestParameters: AssociateLoginsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.associateLoginsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Disassociates the specified login from a user
     * Disassociate
     */
    async disassociateLoginRaw(requestParameters: DisassociateLoginOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling disassociateLogin.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling disassociateLogin.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling disassociateLogin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/auth/users/{user_id}/disassociation`.replace(`{${"user_id"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DisassociateLoginRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Disassociates the specified login from a user
     * Disassociate
     */
    async disassociateLogin(requestParameters: DisassociateLoginOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.disassociateLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Logs in the user based on the discord token specified and returns a session
     * Discord Login
     */
    async discordLoginRaw(requestParameters: DiscordLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthDiscordLoginResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling discordLogin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/auth/discord/login`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AuthDiscordLoginRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthDiscordLoginResponseFromJSON(jsonValue));
    }

    /**
     * Logs in the user based on the discord token specified and returns a session
     * Discord Login
     */
    async discordLogin(requestParameters: DiscordLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthDiscordLoginResponse> {
        const response = await this.discordLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Logs in the user based on the email and OTP specified and returns a session
     * Email Login
     */
    async emailLoginRaw(requestParameters: EmailLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthEmailLoginResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling emailLogin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/auth/login/email`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AuthEmailLoginRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthEmailLoginResponseFromJSON(jsonValue));
    }

    /**
     * Logs in the user based on the email and OTP specified and returns a session
     * Email Login
     */
    async emailLogin(requestParameters: EmailLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthEmailLoginResponse> {
        const response = await this.emailLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Logs in the user based on the email and password specified and returns a session
     * Email Password Login
     */
    async emailPasswordLoginRaw(requestParameters: EmailPasswordLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthEmailPasswordLoginResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling emailPasswordLogin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/auth/email-password/login`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AuthEmailPasswordLoginRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthEmailPasswordLoginResponseFromJSON(jsonValue));
    }

    /**
     * Logs in the user based on the email and password specified and returns a session
     * Email Password Login
     */
    async emailPasswordLogin(requestParameters: EmailPasswordLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthEmailPasswordLoginResponse> {
        const response = await this.emailPasswordLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Logs in the user based on the epic credentials specified and returns a session
     * Epic Login
     */
    async epicLoginRaw(requestParameters: EpicLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthEpicLoginResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling epicLogin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/auth/login/epic`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AuthEpicLoginRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthEpicLoginResponseFromJSON(jsonValue));
    }

    /**
     * Logs in the user based on the epic credentials specified and returns a session
     * Epic Login
     */
    async epicLogin(requestParameters: EpicLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthEpicLoginResponse> {
        const response = await this.epicLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Logs in the user based on the facebook credential token specified and returns a session
     * Facebook Login
     */
    async facebookLoginRaw(requestParameters: FacebookLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthFacebookLoginResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling facebookLogin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/auth/login/facebook`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AuthFacebookLoginRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthFacebookLoginResponseFromJSON(jsonValue));
    }

    /**
     * Logs in the user based on the facebook credential token specified and returns a session
     * Facebook Login
     */
    async facebookLogin(requestParameters: FacebookLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthFacebookLoginResponse> {
        const response = await this.facebookLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get UserIDs by login IDs and login types
     * Get User Ids
     */
    async getUserIdsByLoginIdsRaw(requestParameters: GetUserIdsByLoginIdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthGetUserIdsByLoginIdsResponse>> {
        if (requestParameters.loginIds === null || requestParameters.loginIds === undefined) {
            throw new runtime.RequiredError('loginIds','Required parameter requestParameters.loginIds was null or undefined when calling getUserIdsByLoginIds.');
        }

        if (requestParameters.loginType === null || requestParameters.loginType === undefined) {
            throw new runtime.RequiredError('loginType','Required parameter requestParameters.loginType was null or undefined when calling getUserIdsByLoginIds.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling getUserIdsByLoginIds.');
        }

        const queryParameters: any = {};

        if (requestParameters.loginIds !== undefined) {
            queryParameters['login_ids'] = requestParameters.loginIds;
        }

        if (requestParameters.loginType !== undefined) {
            queryParameters['login_type'] = requestParameters.loginType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/auth/users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthGetUserIdsByLoginIdsResponseFromJSON(jsonValue));
    }

    /**
     * Get UserIDs by login IDs and login types
     * Get User Ids
     */
    async getUserIdsByLoginIds(requestParameters: GetUserIdsByLoginIdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthGetUserIdsByLoginIdsResponse> {
        const response = await this.getUserIdsByLoginIdsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Checks if the username is available
     * Username Password Login
     */
    async getUsernameAvailabilityRaw(requestParameters: GetUsernameAvailabilityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthGetUsernameAvailabilityResponse>> {
        if (requestParameters.username === null || requestParameters.username === undefined) {
            throw new runtime.RequiredError('username','Required parameter requestParameters.username was null or undefined when calling getUsernameAvailability.');
        }

        const queryParameters: any = {};

        if (requestParameters.username !== undefined) {
            queryParameters['username'] = requestParameters.username;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/auth/username-password/availability`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthGetUsernameAvailabilityResponseFromJSON(jsonValue));
    }

    /**
     * Checks if the username is available
     * Username Password Login
     */
    async getUsernameAvailability(requestParameters: GetUsernameAvailabilityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthGetUsernameAvailabilityResponse> {
        const response = await this.getUsernameAvailabilityRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Logs in the user based on the google credential token specified and returns a session
     * Google Login
     */
    async googleLoginRaw(requestParameters: GoogleLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthGoogleLoginResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling googleLogin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/auth/login/google`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AuthGoogleLoginRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthGoogleLoginResponseFromJSON(jsonValue));
    }

    /**
     * Logs in the user based on the google credential token specified and returns a session
     * Google Login
     */
    async googleLogin(requestParameters: GoogleLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthGoogleLoginResponse> {
        const response = await this.googleLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Ends the current session of the user
     * Logout User
     */
    async logoutRaw(requestParameters: LogoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling logout.');
        }

        if (requestParameters.token2 === null || requestParameters.token2 === undefined) {
            throw new runtime.RequiredError('token2','Required parameter requestParameters.token2 was null or undefined when calling logout.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token2 !== undefined && requestParameters.token2 !== null) {
            headerParameters['Token'] = String(requestParameters.token2);
        }

        const response = await this.request({
            path: `/v1/auth/logout/{token}`.replace(`{${"token"}}`, encodeURIComponent(String(requestParameters.token))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Ends the current session of the user
     * Logout User
     */
    async logout(requestParameters: LogoutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.logoutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generates an OTP and sends it to the email for logging in
     * Email Login
     */
    async otpRaw(requestParameters: OtpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling otp.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/auth/otp`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AuthOtpRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Generates an OTP and sends it to the email for logging in
     * Email Login
     */
    async otp(requestParameters: OtpRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.otpRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Sends an email to the user for account recovery
     * Email Password Login
     */
    async recoverEmailAccountRaw(requestParameters: RecoverEmailAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling recoverEmailAccount.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/auth/email-password/account-recovery`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AuthRecoverEmailAccountRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Sends an email to the user for account recovery
     * Email Password Login
     */
    async recoverEmailAccount(requestParameters: RecoverEmailAccountRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.recoverEmailAccountRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Refreshes the session and returns a new session token with refreshed validity
     * Token
     */
    async refreshRaw(requestParameters: RefreshRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthRefreshResponse>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling refresh.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling refresh.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/auth/refresh`,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: AuthRefreshRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthRefreshResponseFromJSON(jsonValue));
    }

    /**
     * Refreshes the session and returns a new session token with refreshed validity
     * Token
     */
    async refresh(requestParameters: RefreshRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthRefreshResponse> {
        const response = await this.refreshRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Logs in the user based on the steam token specified and returns a session
     * Steam Login
     */
    async steamLoginRaw(requestParameters: SteamLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthSteamLoginResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling steamLogin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/auth/login/steam`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AuthSteamLoginRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthSteamLoginResponseFromJSON(jsonValue));
    }

    /**
     * Logs in the user based on the steam token specified and returns a session
     * Steam Login
     */
    async steamLogin(requestParameters: SteamLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthSteamLoginResponse> {
        const response = await this.steamLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Logs in the user based on the steam open ID token specified and returns a session
     * Steam Login
     */
    async steamOpenIdLoginRaw(requestParameters: SteamOpenIdLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthSteamLoginResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling steamOpenIdLogin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/auth/steam/openid/login`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AuthSteamOpenIdLoginRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthSteamLoginResponseFromJSON(jsonValue));
    }

    /**
     * Logs in the user based on the steam open ID token specified and returns a session
     * Steam Login
     */
    async steamOpenIdLogin(requestParameters: SteamOpenIdLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthSteamLoginResponse> {
        const response = await this.steamOpenIdLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Logs in the user based on the steam session ticket specified and returns a session
     * Steam Login
     */
    async steamSessionTicketLoginRaw(requestParameters: SteamSessionTicketLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthSteamLoginResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling steamSessionTicketLogin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/auth/steam/session-ticket/login`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AuthSteamSessionTicketLoginRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthSteamLoginResponseFromJSON(jsonValue));
    }

    /**
     * Logs in the user based on the steam session ticket specified and returns a session
     * Steam Login
     */
    async steamSessionTicketLogin(requestParameters: SteamSessionTicketLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthSteamLoginResponse> {
        const response = await this.steamSessionTicketLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Suspends a user by their ID
     * Suspend User
     */
    async suspendUserRaw(requestParameters: SuspendUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthSuspendUserResponse>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling suspendUser.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling suspendUser.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling suspendUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/auth/user/{id}/suspend`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SuspendUserRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthSuspendUserResponseFromJSON(jsonValue));
    }

    /**
     * Suspends a user by their ID
     * Suspend User
     */
    async suspendUser(requestParameters: SuspendUserOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthSuspendUserResponse> {
        const response = await this.suspendUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the email and password of the user
     * Email Password Login
     */
    async updateEmailPasswordRaw(requestParameters: UpdateEmailPasswordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling updateEmailPassword.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/auth/email-password/password`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AuthUpdateEmailPasswordRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Updates the email and password of the user
     * Email Password Login
     */
    async updateEmailPassword(requestParameters: UpdateEmailPasswordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.updateEmailPasswordRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the username and password of the user
     * Username Password Login
     */
    async updateUsernamePasswordRaw(requestParameters: UpdateUsernamePasswordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<object>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling updateUsernamePassword.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling updateUsernamePassword.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/auth/username-password/password`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AuthUpdateUsernamePasswordRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Updates the username and password of the user
     * Username Password Login
     */
    async updateUsernamePassword(requestParameters: UpdateUsernamePasswordRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<object> {
        const response = await this.updateUsernamePasswordRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Logs in the user based on the username and password specified and returns a session
     * Username Password Login
     */
    async usernamePasswordLoginRaw(requestParameters: UsernamePasswordLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthUsernamePasswordLoginResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling usernamePasswordLogin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/auth/username-password/login`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AuthUsernamePasswordLoginRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthUsernamePasswordLoginResponseFromJSON(jsonValue));
    }

    /**
     * Logs in the user based on the username and password specified and returns a session
     * Username Password Login
     */
    async usernamePasswordLogin(requestParameters: UsernamePasswordLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthUsernamePasswordLoginResponse> {
        const response = await this.usernamePasswordLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Validates the session of the user and returns the user info
     * Token
     */
    async validateRaw(requestParameters: ValidateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthValidateResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling validate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/auth/validate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AuthValidateRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthValidateResponseFromJSON(jsonValue));
    }

    /**
     * Validates the session of the user and returns the user info
     * Token
     */
    async validate(requestParameters: ValidateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthValidateResponse> {
        const response = await this.validateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Verifies the email and returns a session
     * Email Password Login
     */
    async verifyEmailRaw(requestParameters: VerifyEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthVerifyEmailResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling verifyEmail.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/auth/email-password/verification`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AuthVerifyEmailRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthVerifyEmailResponseFromJSON(jsonValue));
    }

    /**
     * Verifies the email and returns a session
     * Email Password Login
     */
    async verifyEmail(requestParameters: VerifyEmailRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthVerifyEmailResponse> {
        const response = await this.verifyEmailRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Logs in the user based on the xbox token specified and returns a session
     * Xbox Login
     */
    async xboxLoginRaw(requestParameters: XboxLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthXboxLoginResponse>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling xboxLogin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/v1/auth/login/xbox`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AuthXboxLoginRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthXboxLoginResponseFromJSON(jsonValue));
    }

    /**
     * Logs in the user based on the xbox token specified and returns a session
     * Xbox Login
     */
    async xboxLogin(requestParameters: XboxLoginRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthXboxLoginResponse> {
        const response = await this.xboxLoginRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
