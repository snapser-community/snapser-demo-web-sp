/* tslint:disable */
/* eslint-disable */
/**
 * my-dev-cluster
 * Your custom SDK
 *
 * The version of the OpenAPI document: my-dev-cluster: v6 SDK
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AppendArrSubDocumentRequest,
  IncrementCounterRequest,
  InsertBlobRequest,
  InsertJsonBlobRequest,
  PrependArrSubDocumentRequest,
  ReplaceBlobRequest,
  ReplaceJsonBlobRequest,
  StorageAppendArrSubDocumentResponse,
  StorageDeleteAppendBlobResponse,
  StorageDeleteBlobResponse,
  StorageDeleteJsonBlobResponse,
  StorageDeleteSubDocumentResponse,
  StorageGetAppendBlobResponse,
  StorageGetBlobResponse,
  StorageGetCasResponse,
  StorageGetCounterResponse,
  StorageGetJsonBlobResponse,
  StorageGetSubDocumentResponse,
  StorageIncrementCounterResponse,
  StorageInsertBlobResponse,
  StorageInsertJsonBlobResponse,
  StoragePrependArrSubDocumentResponse,
  StorageReplaceBlobResponse,
  StorageReplaceJsonBlobResponse,
  StorageResetCounterResponse,
  StorageUpdateAppendBlobResponse,
  StorageUpsertSubDocumentResponse,
  UpdateAppendBlobRequest,
  UpsertSubDocumentRequest,
} from '../models/index';
import {
    AppendArrSubDocumentRequestFromJSON,
    AppendArrSubDocumentRequestToJSON,
    IncrementCounterRequestFromJSON,
    IncrementCounterRequestToJSON,
    InsertBlobRequestFromJSON,
    InsertBlobRequestToJSON,
    InsertJsonBlobRequestFromJSON,
    InsertJsonBlobRequestToJSON,
    PrependArrSubDocumentRequestFromJSON,
    PrependArrSubDocumentRequestToJSON,
    ReplaceBlobRequestFromJSON,
    ReplaceBlobRequestToJSON,
    ReplaceJsonBlobRequestFromJSON,
    ReplaceJsonBlobRequestToJSON,
    StorageAppendArrSubDocumentResponseFromJSON,
    StorageAppendArrSubDocumentResponseToJSON,
    StorageDeleteAppendBlobResponseFromJSON,
    StorageDeleteAppendBlobResponseToJSON,
    StorageDeleteBlobResponseFromJSON,
    StorageDeleteBlobResponseToJSON,
    StorageDeleteJsonBlobResponseFromJSON,
    StorageDeleteJsonBlobResponseToJSON,
    StorageDeleteSubDocumentResponseFromJSON,
    StorageDeleteSubDocumentResponseToJSON,
    StorageGetAppendBlobResponseFromJSON,
    StorageGetAppendBlobResponseToJSON,
    StorageGetBlobResponseFromJSON,
    StorageGetBlobResponseToJSON,
    StorageGetCasResponseFromJSON,
    StorageGetCasResponseToJSON,
    StorageGetCounterResponseFromJSON,
    StorageGetCounterResponseToJSON,
    StorageGetJsonBlobResponseFromJSON,
    StorageGetJsonBlobResponseToJSON,
    StorageGetSubDocumentResponseFromJSON,
    StorageGetSubDocumentResponseToJSON,
    StorageIncrementCounterResponseFromJSON,
    StorageIncrementCounterResponseToJSON,
    StorageInsertBlobResponseFromJSON,
    StorageInsertBlobResponseToJSON,
    StorageInsertJsonBlobResponseFromJSON,
    StorageInsertJsonBlobResponseToJSON,
    StoragePrependArrSubDocumentResponseFromJSON,
    StoragePrependArrSubDocumentResponseToJSON,
    StorageReplaceBlobResponseFromJSON,
    StorageReplaceBlobResponseToJSON,
    StorageReplaceJsonBlobResponseFromJSON,
    StorageReplaceJsonBlobResponseToJSON,
    StorageResetCounterResponseFromJSON,
    StorageResetCounterResponseToJSON,
    StorageUpdateAppendBlobResponseFromJSON,
    StorageUpdateAppendBlobResponseToJSON,
    StorageUpsertSubDocumentResponseFromJSON,
    StorageUpsertSubDocumentResponseToJSON,
    UpdateAppendBlobRequestFromJSON,
    UpdateAppendBlobRequestToJSON,
    UpsertSubDocumentRequestFromJSON,
    UpsertSubDocumentRequestToJSON,
} from '../models/index';

export interface StorageAppendArrSubDocumentRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    token: string;
    body: AppendArrSubDocumentRequest;
}

export interface StorageDeleteAppendBlobRequest {
    ownerId: string;
    accessType: string;
    appendBlobKey: string;
    token: string;
    cas?: string;
}

export interface StorageDeleteBlobRequest {
    ownerId: string;
    accessType: string;
    blobKey: string;
    token: string;
    cas?: string;
}

export interface StorageDeleteJsonBlobRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    token: string;
    cas?: string;
}

export interface StorageDeleteSubDocumentRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    path: string;
    token: string;
    cas?: string;
}

export interface StorageGetAppendBlobRequest {
    ownerId: string;
    accessType: string;
    appendBlobKey: string;
    token: string;
}

export interface StorageGetBlobRequest {
    ownerId: string;
    accessType: string;
    blobKey: string;
    token: string;
}

export interface StorageGetCasRequest {
    ownerId: string;
    accessType: string;
    blobKey: string;
    token: string;
}

export interface StorageGetCounterRequest {
    ownerId: string;
    accessType: string;
    counterKey: string;
    token: string;
}

export interface StorageGetJsonBlobRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    token: string;
}

export interface StorageGetSubDocumentRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    path: string;
    token: string;
}

export interface StorageIncrementCounterRequest {
    ownerId: string;
    accessType: string;
    counterKey: string;
    token: string;
    body: IncrementCounterRequest;
}

export interface StorageInsertBlobRequest {
    ownerId: string;
    accessType: string;
    blobKey: string;
    token: string;
    body: InsertBlobRequest;
}

export interface StorageInsertJsonBlobRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    token: string;
    body: InsertJsonBlobRequest;
}

export interface StoragePrependArrSubDocumentRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    token: string;
    body: PrependArrSubDocumentRequest;
}

export interface StorageReplaceBlobRequest {
    ownerId: string;
    accessType: string;
    blobKey: string;
    token: string;
    body: ReplaceBlobRequest;
}

export interface StorageReplaceJsonBlobRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    token: string;
    body: ReplaceJsonBlobRequest;
}

export interface StorageResetCounterRequest {
    ownerId: string;
    accessType: string;
    counterKey: string;
    token: string;
}

export interface StorageUpdateAppendBlobRequest {
    ownerId: string;
    accessType: string;
    appendBlobKey: string;
    token: string;
    body: UpdateAppendBlobRequest;
}

export interface StorageUpsertSubDocumentRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    token: string;
    body: UpsertSubDocumentRequest;
}

/**
 * 
 */
export class StorageServiceApi extends runtime.BaseAPI {

    /**
     * Append to an array sub-document
     * JSON Blobs
     */
    async storageAppendArrSubDocumentRaw(requestParameters: StorageAppendArrSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageAppendArrSubDocumentResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageAppendArrSubDocument.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageAppendArrSubDocument.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling storageAppendArrSubDocument.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageAppendArrSubDocument.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling storageAppendArrSubDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}/sub-documents:append`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AppendArrSubDocumentRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageAppendArrSubDocumentResponseFromJSON(jsonValue));
    }

    /**
     * Append to an array sub-document
     * JSON Blobs
     */
    async storageAppendArrSubDocument(requestParameters: StorageAppendArrSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageAppendArrSubDocumentResponse> {
        const response = await this.storageAppendArrSubDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes the append blob
     * Append Blobs
     */
    async storageDeleteAppendBlobRaw(requestParameters: StorageDeleteAppendBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageDeleteAppendBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageDeleteAppendBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageDeleteAppendBlob.');
        }

        if (requestParameters.appendBlobKey === null || requestParameters.appendBlobKey === undefined) {
            throw new runtime.RequiredError('appendBlobKey','Required parameter requestParameters.appendBlobKey was null or undefined when calling storageDeleteAppendBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageDeleteAppendBlob.');
        }

        const queryParameters: any = {};

        if (requestParameters.cas !== undefined) {
            queryParameters['cas'] = requestParameters.cas;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/append-blobs/{append_blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"append_blob_key"}}`, encodeURIComponent(String(requestParameters.appendBlobKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageDeleteAppendBlobResponseFromJSON(jsonValue));
    }

    /**
     * Deletes the append blob
     * Append Blobs
     */
    async storageDeleteAppendBlob(requestParameters: StorageDeleteAppendBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageDeleteAppendBlobResponse> {
        const response = await this.storageDeleteAppendBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a blob
     * Blobs
     */
    async storageDeleteBlobRaw(requestParameters: StorageDeleteBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageDeleteBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageDeleteBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageDeleteBlob.');
        }

        if (requestParameters.blobKey === null || requestParameters.blobKey === undefined) {
            throw new runtime.RequiredError('blobKey','Required parameter requestParameters.blobKey was null or undefined when calling storageDeleteBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageDeleteBlob.');
        }

        const queryParameters: any = {};

        if (requestParameters.cas !== undefined) {
            queryParameters['cas'] = requestParameters.cas;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/blobs/{blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"blob_key"}}`, encodeURIComponent(String(requestParameters.blobKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageDeleteBlobResponseFromJSON(jsonValue));
    }

    /**
     * Delete a blob
     * Blobs
     */
    async storageDeleteBlob(requestParameters: StorageDeleteBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageDeleteBlobResponse> {
        const response = await this.storageDeleteBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes the JSON blob
     * JSON Blobs
     */
    async storageDeleteJsonBlobRaw(requestParameters: StorageDeleteJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageDeleteJsonBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageDeleteJsonBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageDeleteJsonBlob.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling storageDeleteJsonBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageDeleteJsonBlob.');
        }

        const queryParameters: any = {};

        if (requestParameters.cas !== undefined) {
            queryParameters['cas'] = requestParameters.cas;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageDeleteJsonBlobResponseFromJSON(jsonValue));
    }

    /**
     * Deletes the JSON blob
     * JSON Blobs
     */
    async storageDeleteJsonBlob(requestParameters: StorageDeleteJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageDeleteJsonBlobResponse> {
        const response = await this.storageDeleteJsonBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes the sub-document
     * JSON Blobs
     */
    async storageDeleteSubDocumentRaw(requestParameters: StorageDeleteSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageDeleteSubDocumentResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageDeleteSubDocument.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageDeleteSubDocument.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling storageDeleteSubDocument.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling storageDeleteSubDocument.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageDeleteSubDocument.');
        }

        const queryParameters: any = {};

        if (requestParameters.cas !== undefined) {
            queryParameters['cas'] = requestParameters.cas;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}/sub-documents/{path}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageDeleteSubDocumentResponseFromJSON(jsonValue));
    }

    /**
     * Deletes the sub-document
     * JSON Blobs
     */
    async storageDeleteSubDocument(requestParameters: StorageDeleteSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageDeleteSubDocumentResponse> {
        const response = await this.storageDeleteSubDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the value of an append blob
     * Append Blobs
     */
    async storageGetAppendBlobRaw(requestParameters: StorageGetAppendBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageGetAppendBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageGetAppendBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageGetAppendBlob.');
        }

        if (requestParameters.appendBlobKey === null || requestParameters.appendBlobKey === undefined) {
            throw new runtime.RequiredError('appendBlobKey','Required parameter requestParameters.appendBlobKey was null or undefined when calling storageGetAppendBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageGetAppendBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/append-blobs/{append_blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"append_blob_key"}}`, encodeURIComponent(String(requestParameters.appendBlobKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageGetAppendBlobResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the value of an append blob
     * Append Blobs
     */
    async storageGetAppendBlob(requestParameters: StorageGetAppendBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageGetAppendBlobResponse> {
        const response = await this.storageGetAppendBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the blob for the key
     * Blobs
     */
    async storageGetBlobRaw(requestParameters: StorageGetBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageGetBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageGetBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageGetBlob.');
        }

        if (requestParameters.blobKey === null || requestParameters.blobKey === undefined) {
            throw new runtime.RequiredError('blobKey','Required parameter requestParameters.blobKey was null or undefined when calling storageGetBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageGetBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/blobs/{blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"blob_key"}}`, encodeURIComponent(String(requestParameters.blobKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageGetBlobResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the blob for the key
     * Blobs
     */
    async storageGetBlob(requestParameters: StorageGetBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageGetBlobResponse> {
        const response = await this.storageGetBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the cas for the key
     * Cas
     */
    async storageGetCasRaw(requestParameters: StorageGetCasRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageGetCasResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageGetCas.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageGetCas.');
        }

        if (requestParameters.blobKey === null || requestParameters.blobKey === undefined) {
            throw new runtime.RequiredError('blobKey','Required parameter requestParameters.blobKey was null or undefined when calling storageGetCas.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageGetCas.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/cas/{blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"blob_key"}}`, encodeURIComponent(String(requestParameters.blobKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageGetCasResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the cas for the key
     * Cas
     */
    async storageGetCas(requestParameters: StorageGetCasRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageGetCasResponse> {
        const response = await this.storageGetCasRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a counter value
     * Counters
     */
    async storageGetCounterRaw(requestParameters: StorageGetCounterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageGetCounterResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageGetCounter.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageGetCounter.');
        }

        if (requestParameters.counterKey === null || requestParameters.counterKey === undefined) {
            throw new runtime.RequiredError('counterKey','Required parameter requestParameters.counterKey was null or undefined when calling storageGetCounter.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageGetCounter.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/counters/{counter_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"counter_key"}}`, encodeURIComponent(String(requestParameters.counterKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageGetCounterResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a counter value
     * Counters
     */
    async storageGetCounter(requestParameters: StorageGetCounterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageGetCounterResponse> {
        const response = await this.storageGetCounterRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the JSON blob for the key
     * JSON Blobs
     */
    async storageGetJsonBlobRaw(requestParameters: StorageGetJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageGetJsonBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageGetJsonBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageGetJsonBlob.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling storageGetJsonBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageGetJsonBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageGetJsonBlobResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the JSON blob for the key
     * JSON Blobs
     */
    async storageGetJsonBlob(requestParameters: StorageGetJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageGetJsonBlobResponse> {
        const response = await this.storageGetJsonBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the sub-document for the key
     * JSON Blobs
     */
    async storageGetSubDocumentRaw(requestParameters: StorageGetSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageGetSubDocumentResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageGetSubDocument.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageGetSubDocument.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling storageGetSubDocument.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling storageGetSubDocument.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageGetSubDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}/sub-documents/{path}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageGetSubDocumentResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the sub-document for the key
     * JSON Blobs
     */
    async storageGetSubDocument(requestParameters: StorageGetSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageGetSubDocumentResponse> {
        const response = await this.storageGetSubDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Increment the counter
     * Counters
     */
    async storageIncrementCounterRaw(requestParameters: StorageIncrementCounterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageIncrementCounterResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageIncrementCounter.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageIncrementCounter.');
        }

        if (requestParameters.counterKey === null || requestParameters.counterKey === undefined) {
            throw new runtime.RequiredError('counterKey','Required parameter requestParameters.counterKey was null or undefined when calling storageIncrementCounter.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageIncrementCounter.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling storageIncrementCounter.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/counters/{counter_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"counter_key"}}`, encodeURIComponent(String(requestParameters.counterKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IncrementCounterRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageIncrementCounterResponseFromJSON(jsonValue));
    }

    /**
     * Increment the counter
     * Counters
     */
    async storageIncrementCounter(requestParameters: StorageIncrementCounterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageIncrementCounterResponse> {
        const response = await this.storageIncrementCounterRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Inserts a blob. Will fail if the key already exists
     * Blobs
     */
    async storageInsertBlobRaw(requestParameters: StorageInsertBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageInsertBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageInsertBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageInsertBlob.');
        }

        if (requestParameters.blobKey === null || requestParameters.blobKey === undefined) {
            throw new runtime.RequiredError('blobKey','Required parameter requestParameters.blobKey was null or undefined when calling storageInsertBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageInsertBlob.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling storageInsertBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/blobs/{blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"blob_key"}}`, encodeURIComponent(String(requestParameters.blobKey))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InsertBlobRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageInsertBlobResponseFromJSON(jsonValue));
    }

    /**
     * Inserts a blob. Will fail if the key already exists
     * Blobs
     */
    async storageInsertBlob(requestParameters: StorageInsertBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageInsertBlobResponse> {
        const response = await this.storageInsertBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Inserts a JSON blob. Will fail if the key already exists
     * JSON Blobs
     */
    async storageInsertJsonBlobRaw(requestParameters: StorageInsertJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageInsertJsonBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageInsertJsonBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageInsertJsonBlob.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling storageInsertJsonBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageInsertJsonBlob.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling storageInsertJsonBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InsertJsonBlobRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageInsertJsonBlobResponseFromJSON(jsonValue));
    }

    /**
     * Inserts a JSON blob. Will fail if the key already exists
     * JSON Blobs
     */
    async storageInsertJsonBlob(requestParameters: StorageInsertJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageInsertJsonBlobResponse> {
        const response = await this.storageInsertJsonBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Prepend to an array sub-document
     * JSON Blobs
     */
    async storagePrependArrSubDocumentRaw(requestParameters: StoragePrependArrSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoragePrependArrSubDocumentResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storagePrependArrSubDocument.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storagePrependArrSubDocument.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling storagePrependArrSubDocument.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storagePrependArrSubDocument.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling storagePrependArrSubDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}/sub-documents:prepend`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PrependArrSubDocumentRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoragePrependArrSubDocumentResponseFromJSON(jsonValue));
    }

    /**
     * Prepend to an array sub-document
     * JSON Blobs
     */
    async storagePrependArrSubDocument(requestParameters: StoragePrependArrSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoragePrependArrSubDocumentResponse> {
        const response = await this.storagePrependArrSubDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Replace a blob. Optionally insert if it doesn\'t exist
     * Blobs
     */
    async storageReplaceBlobRaw(requestParameters: StorageReplaceBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageReplaceBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageReplaceBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageReplaceBlob.');
        }

        if (requestParameters.blobKey === null || requestParameters.blobKey === undefined) {
            throw new runtime.RequiredError('blobKey','Required parameter requestParameters.blobKey was null or undefined when calling storageReplaceBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageReplaceBlob.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling storageReplaceBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/blobs/{blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"blob_key"}}`, encodeURIComponent(String(requestParameters.blobKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ReplaceBlobRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageReplaceBlobResponseFromJSON(jsonValue));
    }

    /**
     * Replace a blob. Optionally insert if it doesn\'t exist
     * Blobs
     */
    async storageReplaceBlob(requestParameters: StorageReplaceBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageReplaceBlobResponse> {
        const response = await this.storageReplaceBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Replace a JSON blob. Optionally insert if it doesn\'t exist
     * JSON Blobs
     */
    async storageReplaceJsonBlobRaw(requestParameters: StorageReplaceJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageReplaceJsonBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageReplaceJsonBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageReplaceJsonBlob.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling storageReplaceJsonBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageReplaceJsonBlob.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling storageReplaceJsonBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ReplaceJsonBlobRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageReplaceJsonBlobResponseFromJSON(jsonValue));
    }

    /**
     * Replace a JSON blob. Optionally insert if it doesn\'t exist
     * JSON Blobs
     */
    async storageReplaceJsonBlob(requestParameters: StorageReplaceJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageReplaceJsonBlobResponse> {
        const response = await this.storageReplaceJsonBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reset a counter value to 0
     * Counters
     */
    async storageResetCounterRaw(requestParameters: StorageResetCounterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageResetCounterResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageResetCounter.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageResetCounter.');
        }

        if (requestParameters.counterKey === null || requestParameters.counterKey === undefined) {
            throw new runtime.RequiredError('counterKey','Required parameter requestParameters.counterKey was null or undefined when calling storageResetCounter.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageResetCounter.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/counters/{counter_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"counter_key"}}`, encodeURIComponent(String(requestParameters.counterKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageResetCounterResponseFromJSON(jsonValue));
    }

    /**
     * Reset a counter value to 0
     * Counters
     */
    async storageResetCounter(requestParameters: StorageResetCounterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageResetCounterResponse> {
        const response = await this.storageResetCounterRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Apend to the existing blob. Create a new one if it doesn\'t exist
     * Append Blobs
     */
    async storageUpdateAppendBlobRaw(requestParameters: StorageUpdateAppendBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageUpdateAppendBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageUpdateAppendBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageUpdateAppendBlob.');
        }

        if (requestParameters.appendBlobKey === null || requestParameters.appendBlobKey === undefined) {
            throw new runtime.RequiredError('appendBlobKey','Required parameter requestParameters.appendBlobKey was null or undefined when calling storageUpdateAppendBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageUpdateAppendBlob.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling storageUpdateAppendBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/append-blobs/{append_blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"append_blob_key"}}`, encodeURIComponent(String(requestParameters.appendBlobKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateAppendBlobRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageUpdateAppendBlobResponseFromJSON(jsonValue));
    }

    /**
     * Apend to the existing blob. Create a new one if it doesn\'t exist
     * Append Blobs
     */
    async storageUpdateAppendBlob(requestParameters: StorageUpdateAppendBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageUpdateAppendBlobResponse> {
        const response = await this.storageUpdateAppendBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upsert a sub-document. Optionally insert if it doesn\'t exist
     * JSON Blobs
     */
    async storageUpsertSubDocumentRaw(requestParameters: StorageUpsertSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageUpsertSubDocumentResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageUpsertSubDocument.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageUpsertSubDocument.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling storageUpsertSubDocument.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageUpsertSubDocument.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling storageUpsertSubDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}/sub-documents`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpsertSubDocumentRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageUpsertSubDocumentResponseFromJSON(jsonValue));
    }

    /**
     * Upsert a sub-document. Optionally insert if it doesn\'t exist
     * JSON Blobs
     */
    async storageUpsertSubDocument(requestParameters: StorageUpsertSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageUpsertSubDocumentResponse> {
        const response = await this.storageUpsertSubDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
