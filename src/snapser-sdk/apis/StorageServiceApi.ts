/* tslint:disable */
/* eslint-disable */
/**
 * lap-legend-race-game
 * Your custom SDK
 *
 * The version of the OpenAPI document: lap-legend-race-game: v1 SDK
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  StorageAppendArrSubDocumentResponse,
  StorageBatchAppendArrSubDocumentsRequest,
  StorageBatchAppendArrSubDocumentsResponse,
  StorageBatchDeleteJsonBlobsRequest,
  StorageBatchDeleteJsonBlobsResponse,
  StorageBatchDeleteSubDocumentsRequest,
  StorageBatchDeleteSubDocumentsResponse,
  StorageBatchGetAppendBlobsResponse,
  StorageBatchGetBlobsResponse,
  StorageBatchGetCountersResponse,
  StorageBatchGetJsonBlobsRequest,
  StorageBatchGetJsonBlobsResponse,
  StorageBatchGetSubDocumentsRequest,
  StorageBatchGetSubDocumentsResponse,
  StorageBatchIncrementCounterRequest,
  StorageBatchIncrementCounterResponse,
  StorageBatchInsertBlobRequest,
  StorageBatchInsertBlobResponse,
  StorageBatchInsertJsonBlobsRequest,
  StorageBatchInsertJsonBlobsResponse,
  StorageBatchPrependArrSubDocumentsRequest,
  StorageBatchPrependArrSubDocumentsResponse,
  StorageBatchReplaceBlobRequest,
  StorageBatchReplaceBlobResponse,
  StorageBatchReplaceJsonBlobsRequest,
  StorageBatchReplaceJsonBlobsResponse,
  StorageBatchUpdateAppendBlobRequest,
  StorageBatchUpdateAppendBlobResponse,
  StorageBatchUpsertSubDocumentsRequest,
  StorageBatchUpsertSubDocumentsResponse,
  StorageDeleteAppendBlobResponse,
  StorageDeleteBlobResponse,
  StorageDeleteJsonBlobResponse,
  StorageDeleteSubDocumentResponse,
  StorageGetAppendBlobResponse,
  StorageGetBlobResponse,
  StorageGetCasResponse,
  StorageGetCounterResponse,
  StorageGetJsonBlobResponse,
  StorageGetSubDocumentResponse,
  StorageIncrementCounterResponse,
  StorageInsertBlobResponse,
  StorageInsertJsonBlobResponse,
  StoragePrependArrSubDocumentResponse,
  StorageReplaceBlobResponse,
  StorageReplaceJsonBlobResponse,
  StorageResetCounterResponse,
  StorageServiceAppendArrSubDocumentBody,
  StorageServiceIncrementCounterBody,
  StorageServiceInsertBlobBody,
  StorageServiceInsertJsonBlobBody,
  StorageServicePrependArrSubDocumentBody,
  StorageServiceReplaceBlobBody,
  StorageServiceReplaceJsonBlobBody,
  StorageServiceUpdateAppendBlobBody,
  StorageServiceUpsertSubDocumentBody,
  StorageUpdateAppendBlobResponse,
  StorageUpsertSubDocumentResponse,
} from '../models/index';
import {
    StorageAppendArrSubDocumentResponseFromJSON,
    StorageAppendArrSubDocumentResponseToJSON,
    StorageBatchAppendArrSubDocumentsRequestFromJSON,
    StorageBatchAppendArrSubDocumentsRequestToJSON,
    StorageBatchAppendArrSubDocumentsResponseFromJSON,
    StorageBatchAppendArrSubDocumentsResponseToJSON,
    StorageBatchDeleteJsonBlobsRequestFromJSON,
    StorageBatchDeleteJsonBlobsRequestToJSON,
    StorageBatchDeleteJsonBlobsResponseFromJSON,
    StorageBatchDeleteJsonBlobsResponseToJSON,
    StorageBatchDeleteSubDocumentsRequestFromJSON,
    StorageBatchDeleteSubDocumentsRequestToJSON,
    StorageBatchDeleteSubDocumentsResponseFromJSON,
    StorageBatchDeleteSubDocumentsResponseToJSON,
    StorageBatchGetAppendBlobsResponseFromJSON,
    StorageBatchGetAppendBlobsResponseToJSON,
    StorageBatchGetBlobsResponseFromJSON,
    StorageBatchGetBlobsResponseToJSON,
    StorageBatchGetCountersResponseFromJSON,
    StorageBatchGetCountersResponseToJSON,
    StorageBatchGetJsonBlobsRequestFromJSON,
    StorageBatchGetJsonBlobsRequestToJSON,
    StorageBatchGetJsonBlobsResponseFromJSON,
    StorageBatchGetJsonBlobsResponseToJSON,
    StorageBatchGetSubDocumentsRequestFromJSON,
    StorageBatchGetSubDocumentsRequestToJSON,
    StorageBatchGetSubDocumentsResponseFromJSON,
    StorageBatchGetSubDocumentsResponseToJSON,
    StorageBatchIncrementCounterRequestFromJSON,
    StorageBatchIncrementCounterRequestToJSON,
    StorageBatchIncrementCounterResponseFromJSON,
    StorageBatchIncrementCounterResponseToJSON,
    StorageBatchInsertBlobRequestFromJSON,
    StorageBatchInsertBlobRequestToJSON,
    StorageBatchInsertBlobResponseFromJSON,
    StorageBatchInsertBlobResponseToJSON,
    StorageBatchInsertJsonBlobsRequestFromJSON,
    StorageBatchInsertJsonBlobsRequestToJSON,
    StorageBatchInsertJsonBlobsResponseFromJSON,
    StorageBatchInsertJsonBlobsResponseToJSON,
    StorageBatchPrependArrSubDocumentsRequestFromJSON,
    StorageBatchPrependArrSubDocumentsRequestToJSON,
    StorageBatchPrependArrSubDocumentsResponseFromJSON,
    StorageBatchPrependArrSubDocumentsResponseToJSON,
    StorageBatchReplaceBlobRequestFromJSON,
    StorageBatchReplaceBlobRequestToJSON,
    StorageBatchReplaceBlobResponseFromJSON,
    StorageBatchReplaceBlobResponseToJSON,
    StorageBatchReplaceJsonBlobsRequestFromJSON,
    StorageBatchReplaceJsonBlobsRequestToJSON,
    StorageBatchReplaceJsonBlobsResponseFromJSON,
    StorageBatchReplaceJsonBlobsResponseToJSON,
    StorageBatchUpdateAppendBlobRequestFromJSON,
    StorageBatchUpdateAppendBlobRequestToJSON,
    StorageBatchUpdateAppendBlobResponseFromJSON,
    StorageBatchUpdateAppendBlobResponseToJSON,
    StorageBatchUpsertSubDocumentsRequestFromJSON,
    StorageBatchUpsertSubDocumentsRequestToJSON,
    StorageBatchUpsertSubDocumentsResponseFromJSON,
    StorageBatchUpsertSubDocumentsResponseToJSON,
    StorageDeleteAppendBlobResponseFromJSON,
    StorageDeleteAppendBlobResponseToJSON,
    StorageDeleteBlobResponseFromJSON,
    StorageDeleteBlobResponseToJSON,
    StorageDeleteJsonBlobResponseFromJSON,
    StorageDeleteJsonBlobResponseToJSON,
    StorageDeleteSubDocumentResponseFromJSON,
    StorageDeleteSubDocumentResponseToJSON,
    StorageGetAppendBlobResponseFromJSON,
    StorageGetAppendBlobResponseToJSON,
    StorageGetBlobResponseFromJSON,
    StorageGetBlobResponseToJSON,
    StorageGetCasResponseFromJSON,
    StorageGetCasResponseToJSON,
    StorageGetCounterResponseFromJSON,
    StorageGetCounterResponseToJSON,
    StorageGetJsonBlobResponseFromJSON,
    StorageGetJsonBlobResponseToJSON,
    StorageGetSubDocumentResponseFromJSON,
    StorageGetSubDocumentResponseToJSON,
    StorageIncrementCounterResponseFromJSON,
    StorageIncrementCounterResponseToJSON,
    StorageInsertBlobResponseFromJSON,
    StorageInsertBlobResponseToJSON,
    StorageInsertJsonBlobResponseFromJSON,
    StorageInsertJsonBlobResponseToJSON,
    StoragePrependArrSubDocumentResponseFromJSON,
    StoragePrependArrSubDocumentResponseToJSON,
    StorageReplaceBlobResponseFromJSON,
    StorageReplaceBlobResponseToJSON,
    StorageReplaceJsonBlobResponseFromJSON,
    StorageReplaceJsonBlobResponseToJSON,
    StorageResetCounterResponseFromJSON,
    StorageResetCounterResponseToJSON,
    StorageServiceAppendArrSubDocumentBodyFromJSON,
    StorageServiceAppendArrSubDocumentBodyToJSON,
    StorageServiceIncrementCounterBodyFromJSON,
    StorageServiceIncrementCounterBodyToJSON,
    StorageServiceInsertBlobBodyFromJSON,
    StorageServiceInsertBlobBodyToJSON,
    StorageServiceInsertJsonBlobBodyFromJSON,
    StorageServiceInsertJsonBlobBodyToJSON,
    StorageServicePrependArrSubDocumentBodyFromJSON,
    StorageServicePrependArrSubDocumentBodyToJSON,
    StorageServiceReplaceBlobBodyFromJSON,
    StorageServiceReplaceBlobBodyToJSON,
    StorageServiceReplaceJsonBlobBodyFromJSON,
    StorageServiceReplaceJsonBlobBodyToJSON,
    StorageServiceUpdateAppendBlobBodyFromJSON,
    StorageServiceUpdateAppendBlobBodyToJSON,
    StorageServiceUpsertSubDocumentBodyFromJSON,
    StorageServiceUpsertSubDocumentBodyToJSON,
    StorageUpdateAppendBlobResponseFromJSON,
    StorageUpdateAppendBlobResponseToJSON,
    StorageUpsertSubDocumentResponseFromJSON,
    StorageUpsertSubDocumentResponseToJSON,
} from '../models/index';

export interface AppendArrSubDocumentRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    token: string;
    body: StorageServiceAppendArrSubDocumentBody;
}

export interface BatchAppendArrSubDocumentsRequest {
    token: string;
    body: StorageBatchAppendArrSubDocumentsRequest;
}

export interface BatchDeleteJsonBlobsRequest {
    token: string;
    body: StorageBatchDeleteJsonBlobsRequest;
}

export interface BatchDeleteSubDocumentsRequest {
    token: string;
    body: StorageBatchDeleteSubDocumentsRequest;
}

export interface BatchGetAppendBlobsRequest {
    accessType: BatchGetAppendBlobsAccessTypeEnum;
    ownerId: Array<string>;
    appendBlobKey: string;
    token: string;
}

export interface BatchGetBlobsRequest {
    accessType: BatchGetBlobsAccessTypeEnum;
    ownerId: Array<string>;
    blobKey: string;
    token: string;
}

export interface BatchGetCountersRequest {
    accessType: BatchGetCountersAccessTypeEnum;
    ownerId: Array<string>;
    counterKey: string;
    token: string;
}

export interface BatchGetJsonBlobsRequest {
    token: string;
    body: StorageBatchGetJsonBlobsRequest;
}

export interface BatchGetSubDocumentsRequest {
    token: string;
    body: StorageBatchGetSubDocumentsRequest;
}

export interface BatchIncrementCounterRequest {
    token: string;
    body: StorageBatchIncrementCounterRequest;
}

export interface BatchInsertBlobRequest {
    token: string;
    body: StorageBatchInsertBlobRequest;
}

export interface BatchInsertJsonBlobsRequest {
    token: string;
    body: StorageBatchInsertJsonBlobsRequest;
}

export interface BatchPrependArrSubDocumentsRequest {
    token: string;
    body: StorageBatchPrependArrSubDocumentsRequest;
}

export interface BatchReplaceBlobRequest {
    token: string;
    body: StorageBatchReplaceBlobRequest;
}

export interface BatchReplaceJsonBlobsRequest {
    token: string;
    body: StorageBatchReplaceJsonBlobsRequest;
}

export interface BatchUpdateAppendBlobRequest {
    token: string;
    body: StorageBatchUpdateAppendBlobRequest;
}

export interface BatchUpsertSubDocumentsRequest {
    token: string;
    body: StorageBatchUpsertSubDocumentsRequest;
}

export interface DeleteAppendBlobRequest {
    ownerId: string;
    accessType: string;
    appendBlobKey: string;
    token: string;
    cas?: string;
}

export interface DeleteBlobRequest {
    ownerId: string;
    accessType: string;
    blobKey: string;
    token: string;
    cas?: string;
}

export interface DeleteJsonBlobRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    token: string;
    cas?: string;
}

export interface DeleteSubDocumentRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    path: string;
    token: string;
    cas?: string;
}

export interface GetAppendBlobRequest {
    ownerId: string;
    accessType: string;
    appendBlobKey: string;
    token: string;
}

export interface GetBlobRequest {
    ownerId: string;
    accessType: string;
    blobKey: string;
    token: string;
}

export interface GetCasRequest {
    ownerId: string;
    accessType: string;
    blobKey: string;
    token: string;
}

export interface GetCounterRequest {
    ownerId: string;
    accessType: string;
    counterKey: string;
    token: string;
}

export interface GetJsonBlobRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    token: string;
}

export interface GetSubDocumentRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    path: string;
    token: string;
}

export interface IncrementCounterRequest {
    ownerId: string;
    accessType: string;
    counterKey: string;
    token: string;
    body: StorageServiceIncrementCounterBody;
}

export interface InsertBlobRequest {
    ownerId: string;
    accessType: string;
    blobKey: string;
    token: string;
    body: StorageServiceInsertBlobBody;
}

export interface InsertJsonBlobRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    token: string;
    body: StorageServiceInsertJsonBlobBody;
}

export interface PrependArrSubDocumentRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    token: string;
    body: StorageServicePrependArrSubDocumentBody;
}

export interface ReplaceBlobRequest {
    ownerId: string;
    accessType: string;
    blobKey: string;
    token: string;
    body: StorageServiceReplaceBlobBody;
}

export interface ReplaceJsonBlobRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    token: string;
    body: StorageServiceReplaceJsonBlobBody;
}

export interface ResetCounterRequest {
    ownerId: string;
    accessType: string;
    counterKey: string;
    token: string;
}

export interface UpdateAppendBlobRequest {
    ownerId: string;
    accessType: string;
    appendBlobKey: string;
    token: string;
    body: StorageServiceUpdateAppendBlobBody;
}

export interface UpsertSubDocumentRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    token: string;
    body: StorageServiceUpsertSubDocumentBody;
}

/**
 * 
 */
export class StorageServiceApi extends runtime.BaseAPI {

    /**
     * Append to an array sub-document
     * JSON Blobs
     */
    async appendArrSubDocumentRaw(requestParameters: AppendArrSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageAppendArrSubDocumentResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling appendArrSubDocument.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling appendArrSubDocument.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling appendArrSubDocument.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling appendArrSubDocument.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling appendArrSubDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}/sub-documents:append`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: StorageServiceAppendArrSubDocumentBodyToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageAppendArrSubDocumentResponseFromJSON(jsonValue));
    }

    /**
     * Append to an array sub-document
     * JSON Blobs
     */
    async appendArrSubDocument(requestParameters: AppendArrSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageAppendArrSubDocumentResponse> {
        const response = await this.appendArrSubDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Append to multiple array sub-documents
     * JSON Blobs
     */
    async batchAppendArrSubDocumentsRaw(requestParameters: BatchAppendArrSubDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageBatchAppendArrSubDocumentsResponse>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling batchAppendArrSubDocuments.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling batchAppendArrSubDocuments.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/batch/json-blobs/sub-documents:append`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: StorageBatchAppendArrSubDocumentsRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageBatchAppendArrSubDocumentsResponseFromJSON(jsonValue));
    }

    /**
     * Append to multiple array sub-documents
     * JSON Blobs
     */
    async batchAppendArrSubDocuments(requestParameters: BatchAppendArrSubDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageBatchAppendArrSubDocumentsResponse> {
        const response = await this.batchAppendArrSubDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes multiple JSON blobs
     * JSON Blobs
     */
    async batchDeleteJsonBlobsRaw(requestParameters: BatchDeleteJsonBlobsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageBatchDeleteJsonBlobsResponse>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling batchDeleteJsonBlobs.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling batchDeleteJsonBlobs.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/batch/json-blobs:delete`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StorageBatchDeleteJsonBlobsRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageBatchDeleteJsonBlobsResponseFromJSON(jsonValue));
    }

    /**
     * Deletes multiple JSON blobs
     * JSON Blobs
     */
    async batchDeleteJsonBlobs(requestParameters: BatchDeleteJsonBlobsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageBatchDeleteJsonBlobsResponse> {
        const response = await this.batchDeleteJsonBlobsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes multiple sub-documents
     * JSON Blobs
     */
    async batchDeleteSubDocumentsRaw(requestParameters: BatchDeleteSubDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageBatchDeleteSubDocumentsResponse>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling batchDeleteSubDocuments.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling batchDeleteSubDocuments.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/batch/json-blobs/sub-documents:delete`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StorageBatchDeleteSubDocumentsRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageBatchDeleteSubDocumentsResponseFromJSON(jsonValue));
    }

    /**
     * Deletes multiple sub-documents
     * JSON Blobs
     */
    async batchDeleteSubDocuments(requestParameters: BatchDeleteSubDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageBatchDeleteSubDocumentsResponse> {
        const response = await this.batchDeleteSubDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all append blobs for the owners
     * Append Blobs
     */
    async batchGetAppendBlobsRaw(requestParameters: BatchGetAppendBlobsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageBatchGetAppendBlobsResponse>> {
        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling batchGetAppendBlobs.');
        }

        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling batchGetAppendBlobs.');
        }

        if (requestParameters.appendBlobKey === null || requestParameters.appendBlobKey === undefined) {
            throw new runtime.RequiredError('appendBlobKey','Required parameter requestParameters.appendBlobKey was null or undefined when calling batchGetAppendBlobs.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling batchGetAppendBlobs.');
        }

        const queryParameters: any = {};

        if (requestParameters.accessType !== undefined) {
            queryParameters['access_type'] = requestParameters.accessType;
        }

        if (requestParameters.ownerId) {
            queryParameters['owner_id'] = requestParameters.ownerId;
        }

        if (requestParameters.appendBlobKey !== undefined) {
            queryParameters['append_blob_key'] = requestParameters.appendBlobKey;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/batch/append-blobs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageBatchGetAppendBlobsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve all append blobs for the owners
     * Append Blobs
     */
    async batchGetAppendBlobs(requestParameters: BatchGetAppendBlobsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageBatchGetAppendBlobsResponse> {
        const response = await this.batchGetAppendBlobsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all blobs for the owners
     * Blobs
     */
    async batchGetBlobsRaw(requestParameters: BatchGetBlobsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageBatchGetBlobsResponse>> {
        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling batchGetBlobs.');
        }

        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling batchGetBlobs.');
        }

        if (requestParameters.blobKey === null || requestParameters.blobKey === undefined) {
            throw new runtime.RequiredError('blobKey','Required parameter requestParameters.blobKey was null or undefined when calling batchGetBlobs.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling batchGetBlobs.');
        }

        const queryParameters: any = {};

        if (requestParameters.accessType !== undefined) {
            queryParameters['access_type'] = requestParameters.accessType;
        }

        if (requestParameters.ownerId) {
            queryParameters['owner_id'] = requestParameters.ownerId;
        }

        if (requestParameters.blobKey !== undefined) {
            queryParameters['blob_key'] = requestParameters.blobKey;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/batch/blobs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageBatchGetBlobsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve all blobs for the owners
     * Blobs
     */
    async batchGetBlobs(requestParameters: BatchGetBlobsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageBatchGetBlobsResponse> {
        const response = await this.batchGetBlobsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all counters for the owners
     * Counters
     */
    async batchGetCountersRaw(requestParameters: BatchGetCountersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageBatchGetCountersResponse>> {
        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling batchGetCounters.');
        }

        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling batchGetCounters.');
        }

        if (requestParameters.counterKey === null || requestParameters.counterKey === undefined) {
            throw new runtime.RequiredError('counterKey','Required parameter requestParameters.counterKey was null or undefined when calling batchGetCounters.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling batchGetCounters.');
        }

        const queryParameters: any = {};

        if (requestParameters.accessType !== undefined) {
            queryParameters['access_type'] = requestParameters.accessType;
        }

        if (requestParameters.ownerId) {
            queryParameters['owner_id'] = requestParameters.ownerId;
        }

        if (requestParameters.counterKey !== undefined) {
            queryParameters['counter_key'] = requestParameters.counterKey;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/batch/counters`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageBatchGetCountersResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve all counters for the owners
     * Counters
     */
    async batchGetCounters(requestParameters: BatchGetCountersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageBatchGetCountersResponse> {
        const response = await this.batchGetCountersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all JSON blobs for the owners
     * JSON Blobs
     */
    async batchGetJsonBlobsRaw(requestParameters: BatchGetJsonBlobsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageBatchGetJsonBlobsResponse>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling batchGetJsonBlobs.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling batchGetJsonBlobs.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/batch/json-blobs`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StorageBatchGetJsonBlobsRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageBatchGetJsonBlobsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve all JSON blobs for the owners
     * JSON Blobs
     */
    async batchGetJsonBlobs(requestParameters: BatchGetJsonBlobsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageBatchGetJsonBlobsResponse> {
        const response = await this.batchGetJsonBlobsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all sub-documents for the owners
     * JSON Blobs
     */
    async batchGetSubDocumentsRaw(requestParameters: BatchGetSubDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageBatchGetSubDocumentsResponse>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling batchGetSubDocuments.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling batchGetSubDocuments.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/batch/json-blobs/sub-documents`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StorageBatchGetSubDocumentsRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageBatchGetSubDocumentsResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve all sub-documents for the owners
     * JSON Blobs
     */
    async batchGetSubDocuments(requestParameters: BatchGetSubDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageBatchGetSubDocumentsResponse> {
        const response = await this.batchGetSubDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Increment multiple counters
     * Counters
     */
    async batchIncrementCounterRaw(requestParameters: BatchIncrementCounterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageBatchIncrementCounterResponse>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling batchIncrementCounter.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling batchIncrementCounter.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/batch/counters`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: StorageBatchIncrementCounterRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageBatchIncrementCounterResponseFromJSON(jsonValue));
    }

    /**
     * Increment multiple counters
     * Counters
     */
    async batchIncrementCounter(requestParameters: BatchIncrementCounterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageBatchIncrementCounterResponse> {
        const response = await this.batchIncrementCounterRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Inserts multiple blobs. Will fail if the key already exists
     * Blobs
     */
    async batchInsertBlobRaw(requestParameters: BatchInsertBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageBatchInsertBlobResponse>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling batchInsertBlob.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling batchInsertBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/batch/blobs`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StorageBatchInsertBlobRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageBatchInsertBlobResponseFromJSON(jsonValue));
    }

    /**
     * Inserts multiple blobs. Will fail if the key already exists
     * Blobs
     */
    async batchInsertBlob(requestParameters: BatchInsertBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageBatchInsertBlobResponse> {
        const response = await this.batchInsertBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Inserts multiple JSON blobs. Will fail if the key already exists
     * JSON Blobs
     */
    async batchInsertJsonBlobsRaw(requestParameters: BatchInsertJsonBlobsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageBatchInsertJsonBlobsResponse>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling batchInsertJsonBlobs.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling batchInsertJsonBlobs.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/batch/json-blobs:insert`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StorageBatchInsertJsonBlobsRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageBatchInsertJsonBlobsResponseFromJSON(jsonValue));
    }

    /**
     * Inserts multiple JSON blobs. Will fail if the key already exists
     * JSON Blobs
     */
    async batchInsertJsonBlobs(requestParameters: BatchInsertJsonBlobsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageBatchInsertJsonBlobsResponse> {
        const response = await this.batchInsertJsonBlobsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Prepend to multiple array sub-documents
     * JSON Blobs
     */
    async batchPrependArrSubDocumentsRaw(requestParameters: BatchPrependArrSubDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageBatchPrependArrSubDocumentsResponse>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling batchPrependArrSubDocuments.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling batchPrependArrSubDocuments.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/batch/json-blobs/sub-documents:prepend`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: StorageBatchPrependArrSubDocumentsRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageBatchPrependArrSubDocumentsResponseFromJSON(jsonValue));
    }

    /**
     * Prepend to multiple array sub-documents
     * JSON Blobs
     */
    async batchPrependArrSubDocuments(requestParameters: BatchPrependArrSubDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageBatchPrependArrSubDocumentsResponse> {
        const response = await this.batchPrependArrSubDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Replace multiple blobs. Optionally insert if it doesn\'t exist
     * Blobs
     */
    async batchReplaceBlobRaw(requestParameters: BatchReplaceBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageBatchReplaceBlobResponse>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling batchReplaceBlob.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling batchReplaceBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/batch/blobs`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: StorageBatchReplaceBlobRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageBatchReplaceBlobResponseFromJSON(jsonValue));
    }

    /**
     * Replace multiple blobs. Optionally insert if it doesn\'t exist
     * Blobs
     */
    async batchReplaceBlob(requestParameters: BatchReplaceBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageBatchReplaceBlobResponse> {
        const response = await this.batchReplaceBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Replace multiple JSON blobs. Optionally insert if it doesn\'t exist
     * JSON Blobs
     */
    async batchReplaceJsonBlobsRaw(requestParameters: BatchReplaceJsonBlobsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageBatchReplaceJsonBlobsResponse>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling batchReplaceJsonBlobs.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling batchReplaceJsonBlobs.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/batch/json-blobs:replace`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: StorageBatchReplaceJsonBlobsRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageBatchReplaceJsonBlobsResponseFromJSON(jsonValue));
    }

    /**
     * Replace multiple JSON blobs. Optionally insert if it doesn\'t exist
     * JSON Blobs
     */
    async batchReplaceJsonBlobs(requestParameters: BatchReplaceJsonBlobsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageBatchReplaceJsonBlobsResponse> {
        const response = await this.batchReplaceJsonBlobsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Apend to the existing blobs. Create a new one if it doesn\'t exist
     * Append Blobs
     */
    async batchUpdateAppendBlobRaw(requestParameters: BatchUpdateAppendBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageBatchUpdateAppendBlobResponse>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling batchUpdateAppendBlob.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling batchUpdateAppendBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/batch/append-blobs`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: StorageBatchUpdateAppendBlobRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageBatchUpdateAppendBlobResponseFromJSON(jsonValue));
    }

    /**
     * Apend to the existing blobs. Create a new one if it doesn\'t exist
     * Append Blobs
     */
    async batchUpdateAppendBlob(requestParameters: BatchUpdateAppendBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageBatchUpdateAppendBlobResponse> {
        const response = await this.batchUpdateAppendBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upsert multiple sub-documents. Optionally insert if it doesn\'t exist
     * JSON Blobs
     */
    async batchUpsertSubDocumentsRaw(requestParameters: BatchUpsertSubDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageBatchUpsertSubDocumentsResponse>> {
        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling batchUpsertSubDocuments.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling batchUpsertSubDocuments.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/batch/json-blobs/sub-documents`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: StorageBatchUpsertSubDocumentsRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageBatchUpsertSubDocumentsResponseFromJSON(jsonValue));
    }

    /**
     * Upsert multiple sub-documents. Optionally insert if it doesn\'t exist
     * JSON Blobs
     */
    async batchUpsertSubDocuments(requestParameters: BatchUpsertSubDocumentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageBatchUpsertSubDocumentsResponse> {
        const response = await this.batchUpsertSubDocumentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes the append blob
     * Append Blobs
     */
    async deleteAppendBlobRaw(requestParameters: DeleteAppendBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageDeleteAppendBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling deleteAppendBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling deleteAppendBlob.');
        }

        if (requestParameters.appendBlobKey === null || requestParameters.appendBlobKey === undefined) {
            throw new runtime.RequiredError('appendBlobKey','Required parameter requestParameters.appendBlobKey was null or undefined when calling deleteAppendBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling deleteAppendBlob.');
        }

        const queryParameters: any = {};

        if (requestParameters.cas !== undefined) {
            queryParameters['cas'] = requestParameters.cas;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/append-blobs/{append_blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"append_blob_key"}}`, encodeURIComponent(String(requestParameters.appendBlobKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageDeleteAppendBlobResponseFromJSON(jsonValue));
    }

    /**
     * Deletes the append blob
     * Append Blobs
     */
    async deleteAppendBlob(requestParameters: DeleteAppendBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageDeleteAppendBlobResponse> {
        const response = await this.deleteAppendBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a blob
     * Blobs
     */
    async deleteBlobRaw(requestParameters: DeleteBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageDeleteBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling deleteBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling deleteBlob.');
        }

        if (requestParameters.blobKey === null || requestParameters.blobKey === undefined) {
            throw new runtime.RequiredError('blobKey','Required parameter requestParameters.blobKey was null or undefined when calling deleteBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling deleteBlob.');
        }

        const queryParameters: any = {};

        if (requestParameters.cas !== undefined) {
            queryParameters['cas'] = requestParameters.cas;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/blobs/{blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"blob_key"}}`, encodeURIComponent(String(requestParameters.blobKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageDeleteBlobResponseFromJSON(jsonValue));
    }

    /**
     * Delete a blob
     * Blobs
     */
    async deleteBlob(requestParameters: DeleteBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageDeleteBlobResponse> {
        const response = await this.deleteBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes the JSON blob
     * JSON Blobs
     */
    async deleteJsonBlobRaw(requestParameters: DeleteJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageDeleteJsonBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling deleteJsonBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling deleteJsonBlob.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling deleteJsonBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling deleteJsonBlob.');
        }

        const queryParameters: any = {};

        if (requestParameters.cas !== undefined) {
            queryParameters['cas'] = requestParameters.cas;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageDeleteJsonBlobResponseFromJSON(jsonValue));
    }

    /**
     * Deletes the JSON blob
     * JSON Blobs
     */
    async deleteJsonBlob(requestParameters: DeleteJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageDeleteJsonBlobResponse> {
        const response = await this.deleteJsonBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes the sub-document
     * JSON Blobs
     */
    async deleteSubDocumentRaw(requestParameters: DeleteSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageDeleteSubDocumentResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling deleteSubDocument.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling deleteSubDocument.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling deleteSubDocument.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling deleteSubDocument.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling deleteSubDocument.');
        }

        const queryParameters: any = {};

        if (requestParameters.cas !== undefined) {
            queryParameters['cas'] = requestParameters.cas;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}/sub-documents/{path}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageDeleteSubDocumentResponseFromJSON(jsonValue));
    }

    /**
     * Deletes the sub-document
     * JSON Blobs
     */
    async deleteSubDocument(requestParameters: DeleteSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageDeleteSubDocumentResponse> {
        const response = await this.deleteSubDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the value of an append blob
     * Append Blobs
     */
    async getAppendBlobRaw(requestParameters: GetAppendBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageGetAppendBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling getAppendBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling getAppendBlob.');
        }

        if (requestParameters.appendBlobKey === null || requestParameters.appendBlobKey === undefined) {
            throw new runtime.RequiredError('appendBlobKey','Required parameter requestParameters.appendBlobKey was null or undefined when calling getAppendBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling getAppendBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/append-blobs/{append_blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"append_blob_key"}}`, encodeURIComponent(String(requestParameters.appendBlobKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageGetAppendBlobResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the value of an append blob
     * Append Blobs
     */
    async getAppendBlob(requestParameters: GetAppendBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageGetAppendBlobResponse> {
        const response = await this.getAppendBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the blob for the key
     * Blobs
     */
    async getBlobRaw(requestParameters: GetBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageGetBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling getBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling getBlob.');
        }

        if (requestParameters.blobKey === null || requestParameters.blobKey === undefined) {
            throw new runtime.RequiredError('blobKey','Required parameter requestParameters.blobKey was null or undefined when calling getBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling getBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/blobs/{blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"blob_key"}}`, encodeURIComponent(String(requestParameters.blobKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageGetBlobResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the blob for the key
     * Blobs
     */
    async getBlob(requestParameters: GetBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageGetBlobResponse> {
        const response = await this.getBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the cas for the key
     * Cas
     */
    async getCasRaw(requestParameters: GetCasRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageGetCasResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling getCas.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling getCas.');
        }

        if (requestParameters.blobKey === null || requestParameters.blobKey === undefined) {
            throw new runtime.RequiredError('blobKey','Required parameter requestParameters.blobKey was null or undefined when calling getCas.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling getCas.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/cas/{blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"blob_key"}}`, encodeURIComponent(String(requestParameters.blobKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageGetCasResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the cas for the key
     * Cas
     */
    async getCas(requestParameters: GetCasRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageGetCasResponse> {
        const response = await this.getCasRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a counter value
     * Counters
     */
    async getCounterRaw(requestParameters: GetCounterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageGetCounterResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling getCounter.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling getCounter.');
        }

        if (requestParameters.counterKey === null || requestParameters.counterKey === undefined) {
            throw new runtime.RequiredError('counterKey','Required parameter requestParameters.counterKey was null or undefined when calling getCounter.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling getCounter.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/counters/{counter_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"counter_key"}}`, encodeURIComponent(String(requestParameters.counterKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageGetCounterResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a counter value
     * Counters
     */
    async getCounter(requestParameters: GetCounterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageGetCounterResponse> {
        const response = await this.getCounterRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the JSON blob for the key
     * JSON Blobs
     */
    async getJsonBlobRaw(requestParameters: GetJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageGetJsonBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling getJsonBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling getJsonBlob.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling getJsonBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling getJsonBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageGetJsonBlobResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the JSON blob for the key
     * JSON Blobs
     */
    async getJsonBlob(requestParameters: GetJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageGetJsonBlobResponse> {
        const response = await this.getJsonBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the sub-document for the key
     * JSON Blobs
     */
    async getSubDocumentRaw(requestParameters: GetSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageGetSubDocumentResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling getSubDocument.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling getSubDocument.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling getSubDocument.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling getSubDocument.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling getSubDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}/sub-documents/{path}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageGetSubDocumentResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the sub-document for the key
     * JSON Blobs
     */
    async getSubDocument(requestParameters: GetSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageGetSubDocumentResponse> {
        const response = await this.getSubDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Increment the counter
     * Counters
     */
    async incrementCounterRaw(requestParameters: IncrementCounterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageIncrementCounterResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling incrementCounter.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling incrementCounter.');
        }

        if (requestParameters.counterKey === null || requestParameters.counterKey === undefined) {
            throw new runtime.RequiredError('counterKey','Required parameter requestParameters.counterKey was null or undefined when calling incrementCounter.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling incrementCounter.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling incrementCounter.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/counters/{counter_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"counter_key"}}`, encodeURIComponent(String(requestParameters.counterKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: StorageServiceIncrementCounterBodyToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageIncrementCounterResponseFromJSON(jsonValue));
    }

    /**
     * Increment the counter
     * Counters
     */
    async incrementCounter(requestParameters: IncrementCounterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageIncrementCounterResponse> {
        const response = await this.incrementCounterRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Inserts a blob. Will fail if the key already exists
     * Blobs
     */
    async insertBlobRaw(requestParameters: InsertBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageInsertBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling insertBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling insertBlob.');
        }

        if (requestParameters.blobKey === null || requestParameters.blobKey === undefined) {
            throw new runtime.RequiredError('blobKey','Required parameter requestParameters.blobKey was null or undefined when calling insertBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling insertBlob.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling insertBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/blobs/{blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"blob_key"}}`, encodeURIComponent(String(requestParameters.blobKey))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StorageServiceInsertBlobBodyToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageInsertBlobResponseFromJSON(jsonValue));
    }

    /**
     * Inserts a blob. Will fail if the key already exists
     * Blobs
     */
    async insertBlob(requestParameters: InsertBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageInsertBlobResponse> {
        const response = await this.insertBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Inserts a JSON blob. Will fail if the key already exists
     * JSON Blobs
     */
    async insertJsonBlobRaw(requestParameters: InsertJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageInsertJsonBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling insertJsonBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling insertJsonBlob.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling insertJsonBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling insertJsonBlob.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling insertJsonBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StorageServiceInsertJsonBlobBodyToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageInsertJsonBlobResponseFromJSON(jsonValue));
    }

    /**
     * Inserts a JSON blob. Will fail if the key already exists
     * JSON Blobs
     */
    async insertJsonBlob(requestParameters: InsertJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageInsertJsonBlobResponse> {
        const response = await this.insertJsonBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Prepend to an array sub-document
     * JSON Blobs
     */
    async prependArrSubDocumentRaw(requestParameters: PrependArrSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoragePrependArrSubDocumentResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling prependArrSubDocument.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling prependArrSubDocument.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling prependArrSubDocument.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling prependArrSubDocument.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling prependArrSubDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}/sub-documents:prepend`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: StorageServicePrependArrSubDocumentBodyToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoragePrependArrSubDocumentResponseFromJSON(jsonValue));
    }

    /**
     * Prepend to an array sub-document
     * JSON Blobs
     */
    async prependArrSubDocument(requestParameters: PrependArrSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoragePrependArrSubDocumentResponse> {
        const response = await this.prependArrSubDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Replace a blob. Optionally insert if it doesn\'t exist
     * Blobs
     */
    async replaceBlobRaw(requestParameters: ReplaceBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageReplaceBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling replaceBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling replaceBlob.');
        }

        if (requestParameters.blobKey === null || requestParameters.blobKey === undefined) {
            throw new runtime.RequiredError('blobKey','Required parameter requestParameters.blobKey was null or undefined when calling replaceBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling replaceBlob.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/blobs/{blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"blob_key"}}`, encodeURIComponent(String(requestParameters.blobKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: StorageServiceReplaceBlobBodyToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageReplaceBlobResponseFromJSON(jsonValue));
    }

    /**
     * Replace a blob. Optionally insert if it doesn\'t exist
     * Blobs
     */
    async replaceBlob(requestParameters: ReplaceBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageReplaceBlobResponse> {
        const response = await this.replaceBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Replace a JSON blob. Optionally insert if it doesn\'t exist
     * JSON Blobs
     */
    async replaceJsonBlobRaw(requestParameters: ReplaceJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageReplaceJsonBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling replaceJsonBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling replaceJsonBlob.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling replaceJsonBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling replaceJsonBlob.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceJsonBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: StorageServiceReplaceJsonBlobBodyToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageReplaceJsonBlobResponseFromJSON(jsonValue));
    }

    /**
     * Replace a JSON blob. Optionally insert if it doesn\'t exist
     * JSON Blobs
     */
    async replaceJsonBlob(requestParameters: ReplaceJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageReplaceJsonBlobResponse> {
        const response = await this.replaceJsonBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reset a counter value to 0
     * Counters
     */
    async resetCounterRaw(requestParameters: ResetCounterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageResetCounterResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling resetCounter.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling resetCounter.');
        }

        if (requestParameters.counterKey === null || requestParameters.counterKey === undefined) {
            throw new runtime.RequiredError('counterKey','Required parameter requestParameters.counterKey was null or undefined when calling resetCounter.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling resetCounter.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/counters/{counter_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"counter_key"}}`, encodeURIComponent(String(requestParameters.counterKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageResetCounterResponseFromJSON(jsonValue));
    }

    /**
     * Reset a counter value to 0
     * Counters
     */
    async resetCounter(requestParameters: ResetCounterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageResetCounterResponse> {
        const response = await this.resetCounterRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Apend to the existing blob. Create a new one if it doesn\'t exist
     * Append Blobs
     */
    async updateAppendBlobRaw(requestParameters: UpdateAppendBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageUpdateAppendBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling updateAppendBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling updateAppendBlob.');
        }

        if (requestParameters.appendBlobKey === null || requestParameters.appendBlobKey === undefined) {
            throw new runtime.RequiredError('appendBlobKey','Required parameter requestParameters.appendBlobKey was null or undefined when calling updateAppendBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling updateAppendBlob.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling updateAppendBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/append-blobs/{append_blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"append_blob_key"}}`, encodeURIComponent(String(requestParameters.appendBlobKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: StorageServiceUpdateAppendBlobBodyToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageUpdateAppendBlobResponseFromJSON(jsonValue));
    }

    /**
     * Apend to the existing blob. Create a new one if it doesn\'t exist
     * Append Blobs
     */
    async updateAppendBlob(requestParameters: UpdateAppendBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageUpdateAppendBlobResponse> {
        const response = await this.updateAppendBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upsert a sub-document. Optionally insert if it doesn\'t exist
     * JSON Blobs
     */
    async upsertSubDocumentRaw(requestParameters: UpsertSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageUpsertSubDocumentResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling upsertSubDocument.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling upsertSubDocument.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling upsertSubDocument.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling upsertSubDocument.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling upsertSubDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}/sub-documents`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: StorageServiceUpsertSubDocumentBodyToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageUpsertSubDocumentResponseFromJSON(jsonValue));
    }

    /**
     * Upsert a sub-document. Optionally insert if it doesn\'t exist
     * JSON Blobs
     */
    async upsertSubDocument(requestParameters: UpsertSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageUpsertSubDocumentResponse> {
        const response = await this.upsertSubDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const BatchGetAppendBlobsAccessTypeEnum = {
    Public: 'public',
    Private: 'private',
    Protected: 'protected'
} as const;
export type BatchGetAppendBlobsAccessTypeEnum = typeof BatchGetAppendBlobsAccessTypeEnum[keyof typeof BatchGetAppendBlobsAccessTypeEnum];
/**
 * @export
 */
export const BatchGetBlobsAccessTypeEnum = {
    Public: 'public',
    Private: 'private',
    Protected: 'protected'
} as const;
export type BatchGetBlobsAccessTypeEnum = typeof BatchGetBlobsAccessTypeEnum[keyof typeof BatchGetBlobsAccessTypeEnum];
/**
 * @export
 */
export const BatchGetCountersAccessTypeEnum = {
    Public: 'public',
    Private: 'private',
    Protected: 'protected'
} as const;
export type BatchGetCountersAccessTypeEnum = typeof BatchGetCountersAccessTypeEnum[keyof typeof BatchGetCountersAccessTypeEnum];
