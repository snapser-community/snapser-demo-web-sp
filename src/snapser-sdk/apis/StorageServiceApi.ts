/* tslint:disable */
/* eslint-disable */
/**
 * test
 * Your custom SDK
 *
 * The version of the OpenAPI document: test: v1 SDK
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AppendArrSubDocumentRequest,
  IncrementCounterRequest,
  InsertBlobRequest,
  InsertJsonBlobRequest,
  PrependArrSubDocumentRequest,
  ReplaceBlobRequest,
  ReplaceJsonBlobRequest,
  StorageAppendArrSubDocumentResponse,
  StorageDeleteAppendBlobResponse,
  StorageDeleteBlobResponse,
  StorageDeleteJsonBlobResponse,
  StorageDeleteSubDocumentResponse,
  StorageGetAppendBlobResponse,
  StorageGetBlobResponse,
  StorageGetCasResponse,
  StorageGetCounterResponse,
  StorageGetJsonBlobResponse,
  StorageGetSubDocumentResponse,
  StorageIncrementCounterResponse,
  StorageInsertBlobResponse,
  StorageInsertJsonBlobResponse,
  StoragePrependArrSubDocumentResponse,
  StorageReplaceBlobResponse,
  StorageReplaceJsonBlobResponse,
  StorageResetCounterResponse,
  StorageUpdateAppendBlobResponse,
  StorageUpsertSubDocumentResponse,
  UpdateAppendBlobRequest,
  UpsertSubDocumentRequest,
} from '../models/index';
import {
    AppendArrSubDocumentRequestFromJSON,
    AppendArrSubDocumentRequestToJSON,
    IncrementCounterRequestFromJSON,
    IncrementCounterRequestToJSON,
    InsertBlobRequestFromJSON,
    InsertBlobRequestToJSON,
    InsertJsonBlobRequestFromJSON,
    InsertJsonBlobRequestToJSON,
    PrependArrSubDocumentRequestFromJSON,
    PrependArrSubDocumentRequestToJSON,
    ReplaceBlobRequestFromJSON,
    ReplaceBlobRequestToJSON,
    ReplaceJsonBlobRequestFromJSON,
    ReplaceJsonBlobRequestToJSON,
    StorageAppendArrSubDocumentResponseFromJSON,
    StorageAppendArrSubDocumentResponseToJSON,
    StorageDeleteAppendBlobResponseFromJSON,
    StorageDeleteAppendBlobResponseToJSON,
    StorageDeleteBlobResponseFromJSON,
    StorageDeleteBlobResponseToJSON,
    StorageDeleteJsonBlobResponseFromJSON,
    StorageDeleteJsonBlobResponseToJSON,
    StorageDeleteSubDocumentResponseFromJSON,
    StorageDeleteSubDocumentResponseToJSON,
    StorageGetAppendBlobResponseFromJSON,
    StorageGetAppendBlobResponseToJSON,
    StorageGetBlobResponseFromJSON,
    StorageGetBlobResponseToJSON,
    StorageGetCasResponseFromJSON,
    StorageGetCasResponseToJSON,
    StorageGetCounterResponseFromJSON,
    StorageGetCounterResponseToJSON,
    StorageGetJsonBlobResponseFromJSON,
    StorageGetJsonBlobResponseToJSON,
    StorageGetSubDocumentResponseFromJSON,
    StorageGetSubDocumentResponseToJSON,
    StorageIncrementCounterResponseFromJSON,
    StorageIncrementCounterResponseToJSON,
    StorageInsertBlobResponseFromJSON,
    StorageInsertBlobResponseToJSON,
    StorageInsertJsonBlobResponseFromJSON,
    StorageInsertJsonBlobResponseToJSON,
    StoragePrependArrSubDocumentResponseFromJSON,
    StoragePrependArrSubDocumentResponseToJSON,
    StorageReplaceBlobResponseFromJSON,
    StorageReplaceBlobResponseToJSON,
    StorageReplaceJsonBlobResponseFromJSON,
    StorageReplaceJsonBlobResponseToJSON,
    StorageResetCounterResponseFromJSON,
    StorageResetCounterResponseToJSON,
    StorageUpdateAppendBlobResponseFromJSON,
    StorageUpdateAppendBlobResponseToJSON,
    StorageUpsertSubDocumentResponseFromJSON,
    StorageUpsertSubDocumentResponseToJSON,
    UpdateAppendBlobRequestFromJSON,
    UpdateAppendBlobRequestToJSON,
    UpsertSubDocumentRequestFromJSON,
    UpsertSubDocumentRequestToJSON,
} from '../models/index';

export interface StorageUserAppendArrSubDocumentRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    token: string;
    body: AppendArrSubDocumentRequest;
}

export interface StorageUserDeleteAppendBlobRequest {
    ownerId: string;
    accessType: string;
    appendBlobKey: string;
    token: string;
    cas?: string;
}

export interface StorageUserDeleteBlobRequest {
    ownerId: string;
    accessType: string;
    blobKey: string;
    token: string;
    cas?: string;
}

export interface StorageUserDeleteJsonBlobRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    token: string;
    cas?: string;
}

export interface StorageUserDeleteSubDocumentRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    path: string;
    token: string;
    cas?: string;
}

export interface StorageUserGetAppendBlobRequest {
    ownerId: string;
    accessType: string;
    appendBlobKey: string;
    token: string;
}

export interface StorageUserGetBlobRequest {
    ownerId: string;
    accessType: string;
    blobKey: string;
    token: string;
}

export interface StorageUserGetCasRequest {
    ownerId: string;
    accessType: string;
    blobKey: string;
    token: string;
}

export interface StorageUserGetCounterRequest {
    ownerId: string;
    accessType: string;
    counterKey: string;
    token: string;
}

export interface StorageUserGetJsonBlobRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    token: string;
}

export interface StorageUserGetSubDocumentRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    path: string;
    token: string;
}

export interface StorageUserIncrementCounterRequest {
    ownerId: string;
    accessType: string;
    counterKey: string;
    token: string;
    body: IncrementCounterRequest;
}

export interface StorageUserInsertBlobRequest {
    ownerId: string;
    accessType: string;
    blobKey: string;
    token: string;
    body: InsertBlobRequest;
}

export interface StorageUserInsertJsonBlobRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    token: string;
    body: InsertJsonBlobRequest;
}

export interface StorageUserPrependArrSubDocumentRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    token: string;
    body: PrependArrSubDocumentRequest;
}

export interface StorageUserReplaceBlobRequest {
    ownerId: string;
    accessType: string;
    blobKey: string;
    token: string;
    body: ReplaceBlobRequest;
}

export interface StorageUserReplaceJsonBlobRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    token: string;
    body: ReplaceJsonBlobRequest;
}

export interface StorageUserResetCounterRequest {
    ownerId: string;
    accessType: string;
    counterKey: string;
    token: string;
}

export interface StorageUserUpdateAppendBlobRequest {
    ownerId: string;
    accessType: string;
    appendBlobKey: string;
    token: string;
    body: UpdateAppendBlobRequest;
}

export interface StorageUserUpsertSubDocumentRequest {
    ownerId: string;
    accessType: string;
    jsonBlobKey: string;
    token: string;
    body: UpsertSubDocumentRequest;
}

/**
 * 
 */
export class StorageServiceApi extends runtime.BaseAPI {

    /**
     * Append to an array sub-document
     * JSON Blobs
     */
    async storageUserAppendArrSubDocumentRaw(requestParameters: StorageUserAppendArrSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageAppendArrSubDocumentResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageUserAppendArrSubDocument.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageUserAppendArrSubDocument.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling storageUserAppendArrSubDocument.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageUserAppendArrSubDocument.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling storageUserAppendArrSubDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}/sub-documents:append`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AppendArrSubDocumentRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageAppendArrSubDocumentResponseFromJSON(jsonValue));
    }

    /**
     * Append to an array sub-document
     * JSON Blobs
     */
    async storageUserAppendArrSubDocument(requestParameters: StorageUserAppendArrSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageAppendArrSubDocumentResponse> {
        const response = await this.storageUserAppendArrSubDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes the append blob
     * Append Blobs
     */
    async storageUserDeleteAppendBlobRaw(requestParameters: StorageUserDeleteAppendBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageDeleteAppendBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageUserDeleteAppendBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageUserDeleteAppendBlob.');
        }

        if (requestParameters.appendBlobKey === null || requestParameters.appendBlobKey === undefined) {
            throw new runtime.RequiredError('appendBlobKey','Required parameter requestParameters.appendBlobKey was null or undefined when calling storageUserDeleteAppendBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageUserDeleteAppendBlob.');
        }

        const queryParameters: any = {};

        if (requestParameters.cas !== undefined) {
            queryParameters['cas'] = requestParameters.cas;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/append-blobs/{append_blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"append_blob_key"}}`, encodeURIComponent(String(requestParameters.appendBlobKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageDeleteAppendBlobResponseFromJSON(jsonValue));
    }

    /**
     * Deletes the append blob
     * Append Blobs
     */
    async storageUserDeleteAppendBlob(requestParameters: StorageUserDeleteAppendBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageDeleteAppendBlobResponse> {
        const response = await this.storageUserDeleteAppendBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a blob
     * Blobs
     */
    async storageUserDeleteBlobRaw(requestParameters: StorageUserDeleteBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageDeleteBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageUserDeleteBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageUserDeleteBlob.');
        }

        if (requestParameters.blobKey === null || requestParameters.blobKey === undefined) {
            throw new runtime.RequiredError('blobKey','Required parameter requestParameters.blobKey was null or undefined when calling storageUserDeleteBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageUserDeleteBlob.');
        }

        const queryParameters: any = {};

        if (requestParameters.cas !== undefined) {
            queryParameters['cas'] = requestParameters.cas;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/blobs/{blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"blob_key"}}`, encodeURIComponent(String(requestParameters.blobKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageDeleteBlobResponseFromJSON(jsonValue));
    }

    /**
     * Delete a blob
     * Blobs
     */
    async storageUserDeleteBlob(requestParameters: StorageUserDeleteBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageDeleteBlobResponse> {
        const response = await this.storageUserDeleteBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes the JSON blob
     * JSON Blobs
     */
    async storageUserDeleteJsonBlobRaw(requestParameters: StorageUserDeleteJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageDeleteJsonBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageUserDeleteJsonBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageUserDeleteJsonBlob.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling storageUserDeleteJsonBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageUserDeleteJsonBlob.');
        }

        const queryParameters: any = {};

        if (requestParameters.cas !== undefined) {
            queryParameters['cas'] = requestParameters.cas;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageDeleteJsonBlobResponseFromJSON(jsonValue));
    }

    /**
     * Deletes the JSON blob
     * JSON Blobs
     */
    async storageUserDeleteJsonBlob(requestParameters: StorageUserDeleteJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageDeleteJsonBlobResponse> {
        const response = await this.storageUserDeleteJsonBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes the sub-document
     * JSON Blobs
     */
    async storageUserDeleteSubDocumentRaw(requestParameters: StorageUserDeleteSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageDeleteSubDocumentResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageUserDeleteSubDocument.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageUserDeleteSubDocument.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling storageUserDeleteSubDocument.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling storageUserDeleteSubDocument.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageUserDeleteSubDocument.');
        }

        const queryParameters: any = {};

        if (requestParameters.cas !== undefined) {
            queryParameters['cas'] = requestParameters.cas;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}/sub-documents/{path}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageDeleteSubDocumentResponseFromJSON(jsonValue));
    }

    /**
     * Deletes the sub-document
     * JSON Blobs
     */
    async storageUserDeleteSubDocument(requestParameters: StorageUserDeleteSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageDeleteSubDocumentResponse> {
        const response = await this.storageUserDeleteSubDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the value of an append blob
     * Append Blobs
     */
    async storageUserGetAppendBlobRaw(requestParameters: StorageUserGetAppendBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageGetAppendBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageUserGetAppendBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageUserGetAppendBlob.');
        }

        if (requestParameters.appendBlobKey === null || requestParameters.appendBlobKey === undefined) {
            throw new runtime.RequiredError('appendBlobKey','Required parameter requestParameters.appendBlobKey was null or undefined when calling storageUserGetAppendBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageUserGetAppendBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/append-blobs/{append_blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"append_blob_key"}}`, encodeURIComponent(String(requestParameters.appendBlobKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageGetAppendBlobResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the value of an append blob
     * Append Blobs
     */
    async storageUserGetAppendBlob(requestParameters: StorageUserGetAppendBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageGetAppendBlobResponse> {
        const response = await this.storageUserGetAppendBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the blob for the key
     * Blobs
     */
    async storageUserGetBlobRaw(requestParameters: StorageUserGetBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageGetBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageUserGetBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageUserGetBlob.');
        }

        if (requestParameters.blobKey === null || requestParameters.blobKey === undefined) {
            throw new runtime.RequiredError('blobKey','Required parameter requestParameters.blobKey was null or undefined when calling storageUserGetBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageUserGetBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/blobs/{blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"blob_key"}}`, encodeURIComponent(String(requestParameters.blobKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageGetBlobResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the blob for the key
     * Blobs
     */
    async storageUserGetBlob(requestParameters: StorageUserGetBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageGetBlobResponse> {
        const response = await this.storageUserGetBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the cas for the key
     * Cas
     */
    async storageUserGetCasRaw(requestParameters: StorageUserGetCasRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageGetCasResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageUserGetCas.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageUserGetCas.');
        }

        if (requestParameters.blobKey === null || requestParameters.blobKey === undefined) {
            throw new runtime.RequiredError('blobKey','Required parameter requestParameters.blobKey was null or undefined when calling storageUserGetCas.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageUserGetCas.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/cas/{blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"blob_key"}}`, encodeURIComponent(String(requestParameters.blobKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageGetCasResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the cas for the key
     * Cas
     */
    async storageUserGetCas(requestParameters: StorageUserGetCasRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageGetCasResponse> {
        const response = await this.storageUserGetCasRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a counter value
     * Counters
     */
    async storageUserGetCounterRaw(requestParameters: StorageUserGetCounterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageGetCounterResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageUserGetCounter.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageUserGetCounter.');
        }

        if (requestParameters.counterKey === null || requestParameters.counterKey === undefined) {
            throw new runtime.RequiredError('counterKey','Required parameter requestParameters.counterKey was null or undefined when calling storageUserGetCounter.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageUserGetCounter.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/counters/{counter_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"counter_key"}}`, encodeURIComponent(String(requestParameters.counterKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageGetCounterResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a counter value
     * Counters
     */
    async storageUserGetCounter(requestParameters: StorageUserGetCounterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageGetCounterResponse> {
        const response = await this.storageUserGetCounterRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the JSON blob for the key
     * JSON Blobs
     */
    async storageUserGetJsonBlobRaw(requestParameters: StorageUserGetJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageGetJsonBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageUserGetJsonBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageUserGetJsonBlob.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling storageUserGetJsonBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageUserGetJsonBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageGetJsonBlobResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the JSON blob for the key
     * JSON Blobs
     */
    async storageUserGetJsonBlob(requestParameters: StorageUserGetJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageGetJsonBlobResponse> {
        const response = await this.storageUserGetJsonBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the sub-document for the key
     * JSON Blobs
     */
    async storageUserGetSubDocumentRaw(requestParameters: StorageUserGetSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageGetSubDocumentResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageUserGetSubDocument.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageUserGetSubDocument.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling storageUserGetSubDocument.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling storageUserGetSubDocument.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageUserGetSubDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}/sub-documents/{path}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageGetSubDocumentResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve the sub-document for the key
     * JSON Blobs
     */
    async storageUserGetSubDocument(requestParameters: StorageUserGetSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageGetSubDocumentResponse> {
        const response = await this.storageUserGetSubDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Increment the counter
     * Counters
     */
    async storageUserIncrementCounterRaw(requestParameters: StorageUserIncrementCounterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageIncrementCounterResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageUserIncrementCounter.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageUserIncrementCounter.');
        }

        if (requestParameters.counterKey === null || requestParameters.counterKey === undefined) {
            throw new runtime.RequiredError('counterKey','Required parameter requestParameters.counterKey was null or undefined when calling storageUserIncrementCounter.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageUserIncrementCounter.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling storageUserIncrementCounter.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/counters/{counter_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"counter_key"}}`, encodeURIComponent(String(requestParameters.counterKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IncrementCounterRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageIncrementCounterResponseFromJSON(jsonValue));
    }

    /**
     * Increment the counter
     * Counters
     */
    async storageUserIncrementCounter(requestParameters: StorageUserIncrementCounterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageIncrementCounterResponse> {
        const response = await this.storageUserIncrementCounterRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Inserts a blob. Will fail if the key already exists
     * Blobs
     */
    async storageUserInsertBlobRaw(requestParameters: StorageUserInsertBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageInsertBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageUserInsertBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageUserInsertBlob.');
        }

        if (requestParameters.blobKey === null || requestParameters.blobKey === undefined) {
            throw new runtime.RequiredError('blobKey','Required parameter requestParameters.blobKey was null or undefined when calling storageUserInsertBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageUserInsertBlob.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling storageUserInsertBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/blobs/{blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"blob_key"}}`, encodeURIComponent(String(requestParameters.blobKey))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InsertBlobRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageInsertBlobResponseFromJSON(jsonValue));
    }

    /**
     * Inserts a blob. Will fail if the key already exists
     * Blobs
     */
    async storageUserInsertBlob(requestParameters: StorageUserInsertBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageInsertBlobResponse> {
        const response = await this.storageUserInsertBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Inserts a JSON blob. Will fail if the key already exists
     * JSON Blobs
     */
    async storageUserInsertJsonBlobRaw(requestParameters: StorageUserInsertJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageInsertJsonBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageUserInsertJsonBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageUserInsertJsonBlob.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling storageUserInsertJsonBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageUserInsertJsonBlob.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling storageUserInsertJsonBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InsertJsonBlobRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageInsertJsonBlobResponseFromJSON(jsonValue));
    }

    /**
     * Inserts a JSON blob. Will fail if the key already exists
     * JSON Blobs
     */
    async storageUserInsertJsonBlob(requestParameters: StorageUserInsertJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageInsertJsonBlobResponse> {
        const response = await this.storageUserInsertJsonBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Prepend to an array sub-document
     * JSON Blobs
     */
    async storageUserPrependArrSubDocumentRaw(requestParameters: StorageUserPrependArrSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StoragePrependArrSubDocumentResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageUserPrependArrSubDocument.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageUserPrependArrSubDocument.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling storageUserPrependArrSubDocument.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageUserPrependArrSubDocument.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling storageUserPrependArrSubDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}/sub-documents:prepend`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PrependArrSubDocumentRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StoragePrependArrSubDocumentResponseFromJSON(jsonValue));
    }

    /**
     * Prepend to an array sub-document
     * JSON Blobs
     */
    async storageUserPrependArrSubDocument(requestParameters: StorageUserPrependArrSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StoragePrependArrSubDocumentResponse> {
        const response = await this.storageUserPrependArrSubDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Replace a blob. Optionally insert if it doesn\'t exist
     * Blobs
     */
    async storageUserReplaceBlobRaw(requestParameters: StorageUserReplaceBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageReplaceBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageUserReplaceBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageUserReplaceBlob.');
        }

        if (requestParameters.blobKey === null || requestParameters.blobKey === undefined) {
            throw new runtime.RequiredError('blobKey','Required parameter requestParameters.blobKey was null or undefined when calling storageUserReplaceBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageUserReplaceBlob.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling storageUserReplaceBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/blobs/{blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"blob_key"}}`, encodeURIComponent(String(requestParameters.blobKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ReplaceBlobRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageReplaceBlobResponseFromJSON(jsonValue));
    }

    /**
     * Replace a blob. Optionally insert if it doesn\'t exist
     * Blobs
     */
    async storageUserReplaceBlob(requestParameters: StorageUserReplaceBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageReplaceBlobResponse> {
        const response = await this.storageUserReplaceBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Replace a JSON blob. Optionally insert if it doesn\'t exist
     * JSON Blobs
     */
    async storageUserReplaceJsonBlobRaw(requestParameters: StorageUserReplaceJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageReplaceJsonBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageUserReplaceJsonBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageUserReplaceJsonBlob.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling storageUserReplaceJsonBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageUserReplaceJsonBlob.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling storageUserReplaceJsonBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ReplaceJsonBlobRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageReplaceJsonBlobResponseFromJSON(jsonValue));
    }

    /**
     * Replace a JSON blob. Optionally insert if it doesn\'t exist
     * JSON Blobs
     */
    async storageUserReplaceJsonBlob(requestParameters: StorageUserReplaceJsonBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageReplaceJsonBlobResponse> {
        const response = await this.storageUserReplaceJsonBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reset a counter value to 0
     * Counters
     */
    async storageUserResetCounterRaw(requestParameters: StorageUserResetCounterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageResetCounterResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageUserResetCounter.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageUserResetCounter.');
        }

        if (requestParameters.counterKey === null || requestParameters.counterKey === undefined) {
            throw new runtime.RequiredError('counterKey','Required parameter requestParameters.counterKey was null or undefined when calling storageUserResetCounter.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageUserResetCounter.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/counters/{counter_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"counter_key"}}`, encodeURIComponent(String(requestParameters.counterKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageResetCounterResponseFromJSON(jsonValue));
    }

    /**
     * Reset a counter value to 0
     * Counters
     */
    async storageUserResetCounter(requestParameters: StorageUserResetCounterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageResetCounterResponse> {
        const response = await this.storageUserResetCounterRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Apend to the existing blob. Create a new one if it doesn\'t exist
     * Append Blobs
     */
    async storageUserUpdateAppendBlobRaw(requestParameters: StorageUserUpdateAppendBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageUpdateAppendBlobResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageUserUpdateAppendBlob.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageUserUpdateAppendBlob.');
        }

        if (requestParameters.appendBlobKey === null || requestParameters.appendBlobKey === undefined) {
            throw new runtime.RequiredError('appendBlobKey','Required parameter requestParameters.appendBlobKey was null or undefined when calling storageUserUpdateAppendBlob.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageUserUpdateAppendBlob.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling storageUserUpdateAppendBlob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/append-blobs/{append_blob_key}`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"append_blob_key"}}`, encodeURIComponent(String(requestParameters.appendBlobKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateAppendBlobRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageUpdateAppendBlobResponseFromJSON(jsonValue));
    }

    /**
     * Apend to the existing blob. Create a new one if it doesn\'t exist
     * Append Blobs
     */
    async storageUserUpdateAppendBlob(requestParameters: StorageUserUpdateAppendBlobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageUpdateAppendBlobResponse> {
        const response = await this.storageUserUpdateAppendBlobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upsert a sub-document. Optionally insert if it doesn\'t exist
     * JSON Blobs
     */
    async storageUserUpsertSubDocumentRaw(requestParameters: StorageUserUpsertSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StorageUpsertSubDocumentResponse>> {
        if (requestParameters.ownerId === null || requestParameters.ownerId === undefined) {
            throw new runtime.RequiredError('ownerId','Required parameter requestParameters.ownerId was null or undefined when calling storageUserUpsertSubDocument.');
        }

        if (requestParameters.accessType === null || requestParameters.accessType === undefined) {
            throw new runtime.RequiredError('accessType','Required parameter requestParameters.accessType was null or undefined when calling storageUserUpsertSubDocument.');
        }

        if (requestParameters.jsonBlobKey === null || requestParameters.jsonBlobKey === undefined) {
            throw new runtime.RequiredError('jsonBlobKey','Required parameter requestParameters.jsonBlobKey was null or undefined when calling storageUserUpsertSubDocument.');
        }

        if (requestParameters.token === null || requestParameters.token === undefined) {
            throw new runtime.RequiredError('token','Required parameter requestParameters.token was null or undefined when calling storageUserUpsertSubDocument.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling storageUserUpsertSubDocument.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.token !== undefined && requestParameters.token !== null) {
            headerParameters['Token'] = String(requestParameters.token);
        }

        const response = await this.request({
            path: `/v1/storage/owner/{owner_id}/{access_type}/json-blobs/{json_blob_key}/sub-documents`.replace(`{${"owner_id"}}`, encodeURIComponent(String(requestParameters.ownerId))).replace(`{${"access_type"}}`, encodeURIComponent(String(requestParameters.accessType))).replace(`{${"json_blob_key"}}`, encodeURIComponent(String(requestParameters.jsonBlobKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpsertSubDocumentRequestToJSON(requestParameters.body),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageUpsertSubDocumentResponseFromJSON(jsonValue));
    }

    /**
     * Upsert a sub-document. Optionally insert if it doesn\'t exist
     * JSON Blobs
     */
    async storageUserUpsertSubDocument(requestParameters: StorageUserUpsertSubDocumentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StorageUpsertSubDocumentResponse> {
        const response = await this.storageUserUpsertSubDocumentRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
